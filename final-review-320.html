<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-05-14 Tue 15:52 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Final Review</title>
<meta name="author" content="Nathan  Mull" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="globalStyle.css" />
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Final Review</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org00c9821">1. OCaml</a>
<ul>
<li><a href="#org742c276">1.1. Basics</a></li>
<li><a href="#orga53f48e">1.2. Algebraic Data Types</a></li>
<li><a href="#org3cd0da7">1.3. Record Types</a></li>
<li><a href="#orga91a361">1.4. Higher-Order Programming</a></li>
<li><a href="#org763069a">1.5. Tail Recursion</a></li>
<li><a href="#org95e4ccb">1.6. Type Checking</a></li>
</ul>
</li>
<li><a href="#org5ca1dac">2. Formal Grammar</a>
<ul>
<li><a href="#org8daf64b">2.1. BNF Specifications</a></li>
<li><a href="#org888316c">2.2. Ambiguity</a></li>
<li><a href="#org357dc06">2.3. Regular Grammars</a></li>
<li><a href="#orgcbe1079">2.4. Chomsky Normal Form</a></li>
</ul>
</li>
<li><a href="#orgc2d0547">3. Parsing</a>
<ul>
<li><a href="#org6a444d1">3.1. Combinators</a></li>
</ul>
</li>
<li><a href="#orgf41e697">4. Formal Semantics</a>
<ul>
<li><a href="#org82b08a8">4.1. Derivations</a></li>
<li><a href="#org0a23acb">4.2. Examples</a></li>
</ul>
</li>
<li><a href="#orgde01630">5. Variables</a>
<ul>
<li><a href="#orgc5c95d0">5.1. Stack-Oriented Language with Variables</a></li>
</ul>
</li>
<li><a href="#org0846b42">6. Subroutines</a>
<ul>
<li><a href="#org187cac7">6.1. Stack-Oriented Language with Subroutines</a></li>
<li><a href="#org77fe603">6.2. Parameter Passing</a></li>
</ul>
</li>
<li><a href="#org17891d0">7. Dynamic Scoping</a>
<ul>
<li><a href="#org061188c">7.1. Examples</a></li>
</ul>
</li>
<li><a href="#orgce67e97">8. Lexical Scoping</a>
<ul>
<li><a href="#org8677704">8.1. Activation Records</a></li>
<li><a href="#org78760df">8.2. Closures</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
This page contains an outline of the topics covered in <i>CAS CS 320:
Principles of Programming Languages</i> during the Spring 2023 semester
at Boston University.  It is not exhaustive, though it is biased
towards those topics which are pertinent for the final exam of the
course.  Included are exercises associated with each topic.
</p>
<div id="outline-container-org00c9821" class="outline-2">
<h2 id="org00c9821"><span class="section-number-2">1.</span> OCaml</h2>
<div class="outline-text-2" id="text-1">
<p>
During the first half of the course, we learned the function
programming language <a href="https://ocaml.org">OCaml</a>.  Our primary goal was to learn how to
program in the functional style, not thinking of a function as
defining a list of commands, but instead as specifying the <i>shape</i> of
its output.
</p>
</div>
<div id="outline-container-org742c276" class="outline-3">
<h3 id="org742c276"><span class="section-number-3">1.1.</span> Basics</h3>
<div class="outline-text-3" id="text-1-1">
<p>
OCaml has many types that are standard among programming languages,
e.g., integers, Boolean values, floating-point numbers, tuples and
lists, all with basic operators.  It also has standard functional
language constructs like let-bindings, anonymous functions, and
if-then-else expressions.
</p>
</div>
<div id="outline-container-orgee3f4d8" class="outline-4">
<h4 id="orgee3f4d8"><span class="section-number-4">1.1.1.</span> Exercises</h4>
<div class="outline-text-4" id="text-1-1-1">
<ol class="org-ol">
<li><p>
Euclid's algorithm for determining the greatest common divisor of
two integers takes advantage of the fact that \(\mathsf{gcd}(m, n)
 = \mathsf{gcd}(n, m \bmod n)\).  Implement the function
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">gcd</span> (<span style="color: #a0522d;">m</span> :<span style="color: #228b22;"> int</span>) (<span style="color: #a0522d;">n</span> :<span style="color: #228b22;"> int</span>) :<span style="color: #228b22;"> int </span>=
  <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">TODO</span><span style="color: #b22222;"> *)</span>
</pre>
</div>

<p>
which, given two integers <code>m</code> and <code>n</code>, returns their greatest
common divisor.
</p></li>
<li><p>
We can represent a rational number as a pair of integers where the
first integer represents the numerator and the second represents
the denominator.  We maintain the invariant that the second number
is positive and the pair of numbers are relatively prime.
Implement the function <code>add</code> which adds two rational numbers,
making sure to maintain this invariant.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">rat</span> = int * int

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">add</span> (<span style="color: #a0522d;">m</span> :<span style="color: #228b22;"> rat</span>) (<span style="color: #a0522d;">n</span> :<span style="color: #228b22;"> rat</span>) :<span style="color: #228b22;"> rat </span>=
  <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">TODO</span><span style="color: #b22222;"> *)</span>
</pre>
</div></li>
<li><p>
Implement the function
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a0522d;">gen_fib</span> : (<span style="color: #a0522d;">l</span> :<span style="color: #228b22;"> int list</span>) (<span style="color: #a0522d;">n</span> :<span style="color: #228b22;"> int</span>) :<span style="color: #228b22;"> int </span>=
  <span style="color: #a020f0;">if</span> n &lt; 0
  <span style="color: #a020f0;">then</span> <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span>
  <span style="color: #a020f0;">else</span>
    <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">TODO</span><span style="color: #b22222;"> *)</span>
</pre>
</div>
<p>
which, given a list of integers <code>l</code> of length \(k\) and a nonnegative
integer <code>n</code>, returns the \(n^\text{th}\) element of the following sequence:
</p>
\begin{equation*}
F_n =
\begin{cases}
l[n] & n < k \\
\sum_{i = 1}^k F_{n - i} & n \geq k
\end{cases}
\end{equation*}</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orga53f48e" class="outline-3">
<h3 id="orga53f48e"><span class="section-number-3">1.2.</span> Algebraic Data Types</h3>
<div class="outline-text-3" id="text-1-2">
<p>
One of the most important features of modern functional programming
languages is pattern matching and <a href="https://cs3110.github.io/textbook/chapters/data/algebraic_data_types.html">algebraic data types</a>.  An algebraic
data type (ADT) is defined by giving a collection of <b>constructors</b>,
which themselves can carry other data.  We can think of algebraic data
types as defining <b>unions</b> of existing types.  Here, for example, is
an ADT whose values represent either a Boolean value or an integer.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">bool_or_int</span>
  = <span style="color: #000000; background-color: #ffffff;">Bool</span> <span style="color: #a020f0;">of</span> bool
  | <span style="color: #000000; background-color: #ffffff;">Int</span> <span style="color: #a020f0;">of</span> int
</pre>
</div>
<p>
We work with values of an ADT by <b>pattern matching</b>, providing
different output values depending on the <i>shape</i> of the value we are
matching with.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">num_val</span> (<span style="color: #a0522d;">x</span> :<span style="color: #228b22;"> bool_or_int</span>) :<span style="color: #228b22;"> int </span>=
  <span style="color: #a020f0;">match</span> x <span style="color: #a020f0;">with</span>
  | <span style="color: #000000; background-color: #ffffff;">Bool</span> b -&gt; <span style="color: #a020f0;">if</span> b <span style="color: #a020f0;">then</span> 1 <span style="color: #a020f0;">else</span> 0
  | <span style="color: #000000; background-color: #ffffff;">Int</span> i -&gt; i
</pre>
</div>
<p>
ADTs can be <b>recursive</b> (the type being defined can be referred to in
its own definition) and <b>parametric</b> (the type being defined can
depend parametrically on another type).  These two features are
encompassed in the <code>list</code> type.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">'a mylist</span>
  = <span style="color: #000000; background-color: #ffffff;">Nil</span>
  | <span style="color: #000000; background-color: #ffffff;">Cons</span> <span style="color: #a020f0;">of</span> 'a * 'a mylist
</pre>
</div>

<p>
<code>'a option</code> and <code>'a result</code> two other parametric types which are
important to be familiar with.
</p>
</div>
<div id="outline-container-org25dd813" class="outline-4">
<h4 id="org25dd813"><span class="section-number-4">1.2.1.</span> Exercises</h4>
<div class="outline-text-4" id="text-1-2-1">
<ol class="org-ol">
<li><p>
Implement the function
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">matrix_of_list</span>
  (<span style="color: #a0522d;">l</span> :<span style="color: #228b22;"> 'a list</span>)
  (<span style="color: #a0522d;">num_cols</span> :<span style="color: #228b22;"> int</span>) :<span style="color: #228b22;"> ('a list list) option </span>=
  <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">TODO</span><span style="color: #b22222;"> *)</span>
</pre>
</div>

<p>
which converts a list <code>l</code> into a matrix with <code>num_cols</code> columns,
returing <code>None</code> in the case that <code>num_cols</code> is not positive or the
resulting matrix is not rectangular (i.e., the length of <code>l</code> is not
a multiple of <code>num_cols</code>).
</p></li>
<li><p>
Implement the function
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">drop_nones</span> (<span style="color: #a0522d;">l</span> :<span style="color: #228b22;"> 'a option list</span>) :<span style="color: #228b22;"> 'a list </span>=
  <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">TODO</span><span style="color: #b22222;"> *)</span>
</pre>
</div>

<p>
which returns an <code>'a list</code> consisting of those elements of <code>l</code>
which are not <code>None</code> (in order).
</p></li>
<li><p>
A Red-Black tree is an ordered binary tree in which every node is
labeled either red or black.  It is further required that
</p>
<ul class="org-ul">
<li>no red node has a red child</li>
<li>every path from the root node to the leaf has the same number of
black nodes</li>
</ul>
<p>
Fill in the function <code>is_valid</code> below which returns <code>true</code> if <code>t</code>
is a valid red-black tree, and <code>false</code> otherwise.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">color</span>
  = <span style="color: #000000; background-color: #ffffff;">Red</span>
  | <span style="color: #000000; background-color: #ffffff;">Black</span>

<span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">'a rbtree</span>
  = <span style="color: #000000; background-color: #ffffff;">Leaf</span>
  | <span style="color: #000000; background-color: #ffffff;">Node</span> <span style="color: #a020f0;">of</span> (color * 'a * 'a rbtree * 'a rbtree)

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">is_valid</span> (<span style="color: #a0522d;">t</span> :<span style="color: #228b22;"> 'a rbtree</span>) :<span style="color: #228b22;"> bool </span>=
  <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">TODO</span><span style="color: #b22222;"> *)</span>
</pre>
</div></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org3cd0da7" class="outline-3">
<h3 id="org3cd0da7"><span class="section-number-3">1.3.</span> Record Types</h3>
<div class="outline-text-3" id="text-1-3">
<p>
<b>Record types</b> are essentially tuples with named fields.  Here is an
 example of a representation of rational numbers using record types.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">rat</span> =
  { numer : int
  ; denom : int
  ; is_positive : bool
  }

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a0522d;">two_thirds</span> =
  { numer = 2
  ; denom = 3
  ; is_positive = <span style="color: #008b8b;">true</span>
  }
</pre>
</div>
<p>
If we think of algebraic data types as unions of existing types, then
we may think of record types as <b>products</b> of existing types.  Beyond
this, they have a couple conveniences that are good to remember.
</p>
<ul class="org-ul">
<li>Accessing fields in a record can be done via dot notation, i.e., if
<code>r</code> is a <code>rat</code> then <code>r.is_positive</code> is a <code>bool</code>.</li>
<li><p>
Updating a fields records can be done using <code>with</code>-notation.  This
is useful if a record has many fields but only a few need to be
updated.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">negate</span> (<span style="color: #a0522d;">r</span> :<span style="color: #228b22;"> rat</span>) :<span style="color: #228b22;"> rat </span>=
  { r <span style="color: #a020f0;">with</span> is_positive = <span style="color: #a52a2a;">not</span> r.is_positive }

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">recip</span> (<span style="color: #a0522d;">r</span> :<span style="color: #228b22;"> rat</span>) :<span style="color: #228b22;"> rat </span>=
  <span style="color: #a020f0;">if</span> r.numer = 0
  <span style="color: #a020f0;">then</span> <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span>
  <span style="color: #a020f0;">else</span> { r <span style="color: #a020f0;">with</span> numer = r.denom; denom = r.numer }
</pre>
</div></li>
</ul>
</div>
<div id="outline-container-org08f41c5" class="outline-4">
<h4 id="org08f41c5"><span class="section-number-4">1.3.1.</span> Exercises</h4>
<div class="outline-text-4" id="text-1-3-1">
<ol class="org-ol">
<li><p>
Fill in the record types below so that the given function type-checks.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">rectangle1</span> = <span style="color: #b22222;">(* </span><span style="color: #b22222;">TODO</span><span style="color: #b22222;"> *)</span>

<span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">rectangle2</span> = <span style="color: #b22222;">(* </span><span style="color: #b22222;">TODO</span><span style="color: #b22222;"> *)</span>

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">transform</span> (<span style="color: #a0522d;">r</span> :<span style="color: #228b22;"> rectangle1</span>) :<span style="color: #228b22;"> rectangle2 </span>=
  <span style="color: #000000; font-weight: bold;">let</span> (<span style="color: #a0522d;">x</span>, <span style="color: #a0522d;">y</span>) = r.center <span style="color: #000000; font-weight: bold;">in</span>
  { bottom_left = x -. r.width /. 2., y -. r.height /. 2.
  ; top_right = x +. r.width /. 2., y +. r.height /.  2.
  }
</pre>
</div></li>
<li><p>
Write a function which adds a binding to the list of captured
bindings of a closure, ensuring that it is shadowed by any bindings
already in the collection of captured bindings.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">value</span> = unit <span style="color: #b22222;">(* </span><span style="color: #b22222;">DUMMY TYPE</span><span style="color: #b22222;"> *)</span>
<span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">program</span> = unit <span style="color: #b22222;">(* </span><span style="color: #b22222;">DUMMY TYPE</span><span style="color: #b22222;"> *)</span>
<span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">closure</span> =
  { name : string
  ; body : program
  ; captured : (string * value) list
  }

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">add_binding</span> (<span style="color: #a0522d;">c</span> :<span style="color: #228b22;"> closure</span>) (<span style="color: #a0522d;">x</span> :<span style="color: #228b22;"> string</span>) (<span style="color: #a0522d;">v</span> :<span style="color: #228b22;"> value</span>) =
  <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">TODO</span><span style="color: #b22222;"> *)</span>
</pre>
</div></li>

<li><p>
Suppose you are given a list of tools for converting sound files
from one format to another.  Each converter has a name, a list of
input formats which it can convert from, and a list of output
formats which it can convert to.  Implement the function
<code>convert_options</code> which, given a list of converters <code>cs</code> and an
input format <code>f</code>, collects the possible output formats, keeping
track of the names of the converter tools which can be used.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">converter</span> =
  { name: string
  ; input_formats : string list
  ; output_formats : string list
  }

<span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">convert_out</span> =
  { converters : string list
  ; output_format : string
  }

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">convert_options</span>
  (<span style="color: #a0522d;">cs</span> :<span style="color: #228b22;"> converter list</span>)
  (<span style="color: #a0522d;">f</span> :<span style="color: #228b22;"> string</span>) :<span style="color: #228b22;"> convert_out list </span>=
  <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">TODO</span><span style="color: #b22222;"> *)</span>
</pre>
</div></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orga91a361" class="outline-3">
<h3 id="orga91a361"><span class="section-number-3">1.4.</span> Higher-Order Programming</h3>
<div class="outline-text-3" id="text-1-4">
<p>
<b>Higher-order programming</b> is the use of functions as <b>first-class
values</b> to write general, reusable code.  There are three patterns in
particular for higher-order programming with lists which we looked at
in depth.
</p>
<ul class="org-ul">
<li><p>
The function <code>map</code>, defined as
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #0000ff;">map</span> (<span style="color: #a0522d;">f</span> :<span style="color: #228b22;"> 'a -&gt; 'b</span>) (<span style="color: #a0522d;">l</span> :<span style="color: #228b22;"> 'a list</span>) :<span style="color: #228b22;"> 'b list </span>=
  <span style="color: #a020f0;">match</span> l <span style="color: #a020f0;">with</span>
  | <span style="color: #000000; background-color: #ffffff;">[]</span> -&gt; <span style="color: #000000; background-color: #ffffff;">[]</span>
  | x <span style="color: #000000; background-color: #ffffff;">::</span> l -&gt; <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a0522d;">x</span> = f x <span style="color: #000000; font-weight: bold;">in</span> x <span style="color: #000000; background-color: #ffffff;">::</span> map f l
</pre>
</div>
<p>
replaces each element in <code>l</code> with <code>f</code> applied to that element, in
order from left to right.
</p></li>
<li><p>
The function <code>filter</code>, defined as
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #0000ff;">filter</span> (<span style="color: #a0522d;">p</span> :<span style="color: #228b22;"> 'a -&gt; bool</span>) (<span style="color: #a0522d;">l</span> :<span style="color: #228b22;"> 'a list</span>) :<span style="color: #228b22;"> 'a list </span>=
  <span style="color: #a020f0;">match</span> l <span style="color: #a020f0;">with</span>
  | <span style="color: #000000; background-color: #ffffff;">[]</span> -&gt; <span style="color: #000000; background-color: #ffffff;">[]</span>
  | x <span style="color: #000000; background-color: #ffffff;">::</span> l -&gt; <span style="color: #a020f0;">if</span> p x <span style="color: #a020f0;">then</span> x <span style="color: #000000; background-color: #ffffff;">::</span> filter p l <span style="color: #a020f0;">else</span> filter p l
</pre>
</div>
<p>
collects all element of <code>l</code> which satisfy the predicate <code>p</code>, in order
from left to right.
</p></li>
<li><p>
The function <code>fold_right</code>, defined as
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #0000ff;">fold_right</span> (<span style="color: #a0522d;">f</span> :<span style="color: #228b22;"> 'a -&gt; 'b -&gt; 'b</span>) (<span style="color: #a0522d;">l</span> :<span style="color: #228b22;"> 'a list</span>) (<span style="color: #a0522d;">accu</span> :<span style="color: #228b22;"> 'b</span>) :<span style="color: #228b22;"> 'b </span>=
  <span style="color: #a020f0;">match</span> l <span style="color: #a020f0;">with</span>
  | <span style="color: #000000; background-color: #ffffff;">[]</span> -&gt; accu
  | x <span style="color: #000000; background-color: #ffffff;">::</span> l -&gt; f x (fold_right f l accu)
</pre>
</div>
<p>
applies the binary operation <code>f</code> between every element of <code>l @ [accu]</code> right-associatively:
</p>
<pre class="example">
 [x₁;   x₂;   x₃; ...   xₙ]
  ↓↓    ↓↓    ↓↓        ↓↓
f x₁ (f x₂ (f x₃ (...(f xₙ accu)...)))
</pre>
<p>
and the function <code>fold_left</code>:
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #0000ff;">fold_left</span> (<span style="color: #a0522d;">f</span> :<span style="color: #228b22;"> 'b -&gt; 'a -&gt; 'b</span>) (<span style="color: #a0522d;">accu</span> :<span style="color: #228b22;"> 'b</span>) (<span style="color: #a0522d;">l</span> :<span style="color: #228b22;"> 'a list</span>) :<span style="color: #228b22;"> 'b </span>=
  <span style="color: #a020f0;">match</span> l <span style="color: #a020f0;">with</span>
  | <span style="color: #000000; background-color: #ffffff;">[]</span> -&gt; accu
  | x <span style="color: #000000; background-color: #ffffff;">::</span> l -&gt; fold_left f (f accu x) l
</pre>
</div>
<p>
does the same but to <code>accu :: l</code> left-associatively:
</p>
<pre class="example">
                   [x₁; x₂; x₃; ... xₙ]
                    ↓↓  ↓↓  ↓↓      ↓↓
f (...(f (f (f accu x₁) x₂) x₃)...) xₙ
</pre>
<p>
Note that <code>fold_left</code> is tail-recursive whereas <code>fold_right</code> is not.
</p></li>
</ul>
</div>
<div id="outline-container-orga02cf2d" class="outline-4">
<h4 id="orga02cf2d"><span class="section-number-4">1.4.1.</span> Exercises</h4>
<div class="outline-text-4" id="text-1-4-1">
<ol class="org-ol">
<li><p>
Implement the functions
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">andp</span> (<span style="color: #a0522d;">p1</span> :<span style="color: #228b22;"> 'a -&gt; bool</span>) (<span style="color: #a0522d;">p2</span> :<span style="color: #228b22;"> 'a -&gt; bool</span>) :<span style="color: #228b22;"> 'a -&gt; bool </span>=
  <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">TODO</span><span style="color: #b22222;"> *)</span>

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">orp</span> (<span style="color: #a0522d;">p1</span> :<span style="color: #228b22;"> 'a -&gt; bool</span>) (<span style="color: #a0522d;">p2</span> :<span style="color: #228b22;"> 'a -&gt; bool</span>) :<span style="color: #228b22;"> 'a -&gt; bool </span>=
  <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">TODO</span><span style="color: #b22222;"> *)</span>
</pre>
</div>
<p>
with the following properties:
</p>
<ul class="org-ul">
<li>given two predicates <code>p1</code> and <code>p2</code>, the predicate <code>andp p1 p2</code> is
the predicate which expresses that both <code>p1</code> and <code>p2</code> hold.</li>
<li>given two predicates <code>p1</code> and <code>p2</code>, the predicate <code>orp p1 p2</code> is
the predicate which expresses that <code>p1</code> or <code>p2</code> hold.</li>
</ul></li>
<li><p>
We can represent a polynomial as a list of <code>float</code>'s as follows.
</p>
<pre class="example">
      [a₀;  a₁;    a₂;     ...;  aₙ]
       ↓↓   ↓↓     ↓↓            ↓↓
p(x) = a₀ + a₁ x + a₂ x² + ... + aₙ xⁿ
</pre>
<p>
Implement the function
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">derivative</span> (<span style="color: #a0522d;">p</span> :<span style="color: #228b22;"> float list</span>) :<span style="color: #228b22;"> float list </span>=
  <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">todo</span><span style="color: #b22222;"> *)</span>
</pre>
</div>
<p>
which computes the list representing the polynomial \(p'(x)\), the derivative of \(p(x)\).
</p></li>
<li><p>
When implementing radix sort on integers, it is necessary to partition a list
of integers based on their last digits.  Fill in the following function
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">bucket</span> (<span style="color: #a0522d;">l</span> :<span style="color: #228b22;"> int list</span>) :<span style="color: #228b22;"> int list list </span>=
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">op</span> <span style="color: #a0522d;">accu</span> <span style="color: #a0522d;">next</span> =
    <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">TODO</span><span style="color: #b22222;"> *)</span>
  <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a0522d;">base</span> =
    <span style="color: #228b22;">List.</span>init 10 (<span style="color: #a020f0;">fun</span> <span style="color: #a0522d;">_</span> -&gt; <span style="color: #000000; background-color: #ffffff;">[]</span>)
  <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #228b22;">List.</span>fold_left op base l
</pre>
</div>

<p>
which, given a list <code>l</code> of integers, return 10 lists of integers
which partition <code>l</code> by the last digit the members of <code>l</code>. That is,
the \(i^\text{th}\) element of <code>bucket l</code> should contain exactly the
elements of <code>l</code> whose last digit is \(i\).
</p></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org763069a" class="outline-3">
<h3 id="org763069a"><span class="section-number-3">1.5.</span> Tail Recursion</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Roughly speaking, a recursive call in the body of a function
definition is in <b>tail position</b> if no evaluation is required <i>after</i>
the recursive call.  The following implementation of the factorial
function is not tail recursive because it requires evaluating the
product of the result of its recursive call with the input <code>n</code>.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #0000ff;">factorial</span> (<span style="color: #a0522d;">n</span> :<span style="color: #228b22;"> int</span>) :<span style="color: #228b22;"> int </span>=
  <span style="color: #a020f0;">if</span> n &lt; 0
  <span style="color: #a020f0;">then</span> <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span>
  <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">if</span> n = 0
  <span style="color: #a020f0;">then</span> 1
  <span style="color: #a020f0;">else</span> n * factorial (n - 1)
</pre>
</div>
<p>
We can make functions tail recursive by adding an accumulator argument
to the function.<sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">factorial_tail</span> (<span style="color: #a0522d;">n</span> :<span style="color: #228b22;"> int</span>) :<span style="color: #228b22;"> int </span>=
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #0000ff;">go</span> (<span style="color: #a0522d;">n</span> :<span style="color: #228b22;"> int</span>) (<span style="color: #a0522d;">accu</span> :<span style="color: #228b22;"> int</span>) =
    <span style="color: #a020f0;">if</span> n = 0
    <span style="color: #a020f0;">then</span> accu
    <span style="color: #a020f0;">else</span> go (n - 1) (n * accu)
  <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #a020f0;">if</span> n &lt; 0
  <span style="color: #a020f0;">then</span> <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span>
  <span style="color: #a020f0;">else</span> go n 1
</pre>
</div>
</div>
<div id="outline-container-orgb6ed962" class="outline-4">
<h4 id="orgb6ed962"><span class="section-number-4">1.5.1.</span> Exercises</h4>
<div class="outline-text-4" id="text-1-5-1">
<ol class="org-ol">
<li><p>
Consider the following function which prints a (half) hourglass in
asterisks.  Implement a function which does the same thing but is
tail recursive.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #0000ff;">hourglass</span> (<span style="color: #a0522d;">n</span> :<span style="color: #228b22;"> int</span>) :<span style="color: #228b22;"> unit </span>=
  <span style="color: #a020f0;">if</span> n &gt; 0
  <span style="color: #a020f0;">then</span>
    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a0522d;">_</span> = print_endline (<span style="color: #228b22;">String.</span>make n <span style="color: #8b2252;">'*'</span>) <span style="color: #000000; font-weight: bold;">in</span>
    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a0522d;">_</span> = hourglass (n - 1) <span style="color: #000000; font-weight: bold;">in</span>
    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a0522d;">_</span> = print_endline (<span style="color: #228b22;">String.</span>make n <span style="color: #8b2252;">'*'</span>) <span style="color: #000000; font-weight: bold;">in</span>
    ()
  <span style="color: #a020f0;">else</span> ()
</pre>
</div></li>
<li><p>
<i>(Challenge)</i> Implement a tail recursive evaluator for Boolean expressions as
represented by the following ADT.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">bool_expr</span>
  = <span style="color: #000000; background-color: #ffffff;">Bool</span> <span style="color: #a020f0;">of</span> bool
  | <span style="color: #000000; background-color: #ffffff;">Not</span> <span style="color: #a020f0;">of</span> bool_expr
  | <span style="color: #000000; background-color: #ffffff;">And</span> <span style="color: #a020f0;">of</span> bool_expr * bool_expr
  | <span style="color: #000000; background-color: #ffffff;">Or</span> <span style="color: #a020f0;">of</span> bool_expr * bool_expr

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">eval_tr</span> (<span style="color: #a0522d;">e</span> :<span style="color: #228b22;"> bool_expr</span>) :<span style="color: #228b22;"> bool </span>=
  <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">TODO</span><span style="color: #b22222;"> *)</span>
</pre>
</div></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org95e4ccb" class="outline-3">
<h3 id="org95e4ccb"><span class="section-number-3">1.6.</span> Type Checking</h3>
<div class="outline-text-3" id="text-1-6">
<p>
OCaml is <b>strongly typed</b>, and programs are statically checked for
adherence to typing rules.  We did not look at the type rules in full
detail, but we did see some examples of formal typing rules in OCaml,
e.g.,
</p>
\begin{equation*}
\frac
{b \in \mathsf{bool} \qquad e_1 \in \mathsf{t} \qquad e_2 \in \mathsf{t}}
{(\textsf{if } b \textsf{ then } e_1 \textsf{ else } e_2) \in \mathsf{t}}
\end{equation*}
<p>
This rule expresses that an if-then-else expression has the same type
as its if-case and else-case if its individual sub-expressions are
well-typed.<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>
</p>

<p>
OCaml also has <b>type inference</b>, which means we often do not have to
specify the types of expressions in OCaml programs (though it can be
useful for documentation purposes).
</p>
</div>
<div id="outline-container-org8e3afba" class="outline-4">
<h4 id="org8e3afba"><span class="section-number-4">1.6.1.</span> Exercises</h4>
<div class="outline-text-4" id="text-1-6-1">
<ol class="org-ol">
<li><p>
Does this program type-check? If so, what are the types of <code>bar</code> and <code>baz</code>?
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">'a foo</span> = <span style="color: #000000; background-color: #ffffff;">Foo</span> <span style="color: #a020f0;">of</span> ('a foo -&gt; 'a)
<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">bar</span> (<span style="color: #000000; background-color: #ffffff;">Foo</span> <span style="color: #a0522d;">f</span>) = f
<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">baz</span> <span style="color: #a0522d;">x</span> = bar x x
</pre>
</div></li>
<li><p>
Does this program type-check? If so, what is the type of <code>foo</code>?
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #0000ff;">foo</span> <span style="color: #a0522d;">x</span> <span style="color: #a0522d;">y</span> =
  <span style="color: #a020f0;">if</span> x &gt; 0 <span style="color: #a020f0;">then</span>
    foo (x - 1) (y +. 1.)
  <span style="color: #a020f0;">else</span> <span style="color: #a020f0;">if</span> x &lt; 0 <span style="color: #a020f0;">then</span>
    foo y x
  <span style="color: #a020f0;">else</span>
    0
</pre>
</div></li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-org5ca1dac" class="outline-2">
<h2 id="org5ca1dac"><span class="section-number-2">2.</span> Formal Grammar</h2>
<div class="outline-text-2" id="text-2">
<p>
Grammar is the study of the form and structure of language.  We use
concepts from the formal grammar to represent and reason about the
syntax of programming languages.  These concepts also inform the
design of parsers.
</p>
</div>
<div id="outline-container-org8daf64b" class="outline-3">
<h3 id="org8daf64b"><span class="section-number-3">2.1.</span> BNF Specifications</h3>
<div class="outline-text-3" id="text-2-1">
<p>
We start with a collection of symbols, separated into two disjoint
groups, the <b>nonterminal</b> symbols and the <b>terminal</b> symbols.  In a
Backus-Naur form (BNF) specification we use angle brackets (e.g.,
<code>&lt;nonterm&gt;</code>) to denote a nonterminal symbol.  We typically don't
specify the symbols in advance, but instead glean them from the
specification itself.
</p>

<p>
A <b>sentential form</b> is a sequences of symbols and a <b>sentence</b> is a
sequence of terminal symbols.
</p>

<p>
A <b>production rule</b> is made up of a nonterminal symbol and a
sentential form, and is written
</p>
<pre class="example">
&lt;nonterm&gt; ::= SENTFORM
</pre>
<p>
We interpret a production rule as indicating that <code>&lt;nonterm&gt;</code> <i>stands
for</i> <code>SENTFORM</code> in a sentential from.
</p>

<p>
A <b>BNF specification</b> is given by a collection of production rules and
a <b>starting symbol</b>.  We typically take the nonterminal symbol in the
<i>first</i> rule of the specification to be the starting symbol.  We also
call a BNF specification a <b>grammar</b>.<sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup>
</p>

<p>
In the case that a BNF specification has multiples rules for the same
nonterminal symbol, we use the notation
</p>
<pre class="example">
&lt;nonterm&gt; ::= SENTFORM₁ | SENTFORM₂ | ... | SENTFORMₖ
</pre>
<p>
as shorthand for
</p>
<pre class="example">
&lt;nonterm&gt; ::= SENTFORM₁
&lt;nonterm&gt; ::= SENTFORM₂
 ...
&lt;nonterm&gt; ::= SENTFORMₖ
</pre>

<p>
A <b>derivation</b> of a sentential form \(S\) in a grammar \(\mathcal G\) with
start symbol <code>&lt;start&gt;</code> is a sequence of sentential forms, starting
with the start symbol <code>&lt;start&gt;</code> and ending in \(S\), in which each form
in the sequence (except for <code>&lt;start&gt;</code>) is the results of replacing <i>one</i>
nonterminal symbol in the previous form with a sentential from given
by a production rule of \(\mathcal G\).
</p>

<p>
A derivation is <b>leftmost</b> if the nonterminal symbol replaced at each
step of the derivation is the leftmost nonterminal symbol in the
sentential form.
</p>

<p>
A grammar \(\mathcal G\) <b>accepts</b> or <b>recognizes</b> a sentence
\(S\) if has a derivation in \(\mathcal G\).
</p>

<p>
A <b>parse tree</b>, informally, is a derivation represented as a tree, in which
</p>
<ul class="org-ul">
<li>every node is labeled with a symbol</li>
<li>the root is labeled with the starting symbol</li>
<li>the children of each node are the symbols of the sentential form (in
order) which replace the symbol labeling the node in the derivation.</li>
</ul>

<p>
The <b>frontier</b> of a parse tree (i.e., the leaf nodes in order from
left to right) form the sentence derived in the derivation represented
by the parse tree.
</p>

<p>
A parse tree may correspond to multiple derivations, but every
derivation has a unique parse tree representation.  Likewise, every
parse tree corresponds to a unique <i>leftmost</i> derivation.
</p>
</div>
<div id="outline-container-org434da0e" class="outline-4">
<h4 id="org434da0e"><span class="section-number-4">2.1.1.</span> Examples</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
<i>Toy grammar for English sentences:</i>
</p>
<pre class="example">
&lt;sentence&gt;    ::= &lt;noun-phrase&gt; &lt;verb-phrase&gt;
&lt;verb-phrase&gt; ::= &lt;verb&gt; | &lt;verb&gt; &lt;prep-phrase&gt;
&lt;prep-phrase&gt; ::= &lt;prep&gt; &lt;noun-phrase&gt;
&lt;noun-phrase&gt; ::= &lt;article&gt; &lt;noun&gt;
&lt;article&gt;     ::= the
&lt;noun&gt;        ::= cow | moon
&lt;verb&gt;        ::= jumped
&lt;prep&gt;        ::= over
</pre>
<hr />
<p>
<i>Derivation of a sentence recognized by the above
grammar:</i><sup><a id="fnr.4" class="footref" href="#fn.4" role="doc-backlink">4</a></sup>
</p>

<pre class="example">
&lt;sentence&gt;!
&lt;noun-phrase&gt;!     &lt;verb-phrase&gt;
&lt;noun-phrase&gt;      &lt;verb&gt;  &lt;prep-phrase&gt;!
&lt;noun-phrase&gt;!     &lt;verb&gt;  &lt;prep&gt;  &lt;noun-phrase&gt;
&lt;article&gt;  &lt;noun&gt;  &lt;verb&gt;  &lt;prep&gt;  &lt;noun-phrase&gt;!
&lt;article&gt;! &lt;noun&gt;  &lt;verb&gt;  &lt;prep&gt;  &lt;article&gt;  &lt;noun&gt;
the        &lt;noun&gt;! &lt;verb&gt;  &lt;prep&gt;  &lt;article&gt;  &lt;noun&gt;
the        cow     &lt;verb&gt;! &lt;prep&gt;  &lt;article&gt;  &lt;noun&gt;
the        cow     jumped  &lt;prep&gt;! &lt;article&gt;  &lt;noun&gt;
the        cow     jumped  over    &lt;article&gt;! &lt;noun&gt;
the        cow     jumped  over    the        &lt;noun&gt;!
the        cow     jumped  over    the        moon
</pre>
<hr />
<p>
<i>Toy grammar for an imperative programming language:</i>
</p>
<pre class="example">
&lt;program&gt; ::= &lt;stmts&gt;
&lt;stmts&gt;   ::= &lt;stmt&gt; | &lt;stmt&gt; ; &lt;stmts&gt;
&lt;stmt&gt;    ::= &lt;var&gt; = &lt;expr&gt;
&lt;var&gt;     ::= a | b | c | d
&lt;expr&gt;    ::= &lt;term&gt; | &lt;term&gt; + &lt;term&gt; | &lt;term&gt; - &lt;term&gt;
&lt;term&gt;    ::= &lt;var&gt; | const
</pre>
<hr />
<p>
<i>A (leftmost) derivation of a program recognized by the above grammar:</i>
</p>
<pre class="example">
&lt;program&gt;
&lt;stmts&gt;
&lt;stmt&gt; ; &lt;stmts&gt;
&lt;var&gt; = &lt;expr&gt; ; &lt;stmts&gt;
a = &lt;expr&gt; ; &lt;stmts&gt;
a = &lt;term&gt; ; &lt;stmts&gt;
a = const ; &lt;stmts&gt;
a = const ; &lt;stmt&gt; ; &lt;stmts&gt;
a = const ; &lt;var&gt; = &lt;expr&gt; ; &lt;stmts&gt;
a = const ; a = &lt;expr&gt; ; &lt;stmts&gt;
a = const ; a = &lt;term&gt; + &lt;term&gt; ; &lt;stmts&gt;
a = const ; a = &lt;var&gt; + &lt;term&gt; ; &lt;stmts&gt;
a = const ; a = a + &lt;term&gt; ; &lt;stmts&gt;
a = const ; a = a + const ; &lt;stmts&gt;
a = const ; a = a + const ; &lt;var&gt; = &lt;expr&gt;
a = const ; a = a + const ; b = &lt;expr&gt;
a = const ; a = a + const ; b = &lt;term&gt;
a = const ; a = a + const ; b = &lt;var&gt;
a = const ; a = a + const ; b = a
</pre>
</div>
</div>
<div id="outline-container-orgd2352eb" class="outline-4">
<h4 id="orgd2352eb"><span class="section-number-4">2.1.2.</span> Extended BNF</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
We extend the notation of BNF specifications to make it more
convenient to use.<sup><a id="fnr.5" class="footref" href="#fn.5" role="doc-backlink">5</a></sup>
</p>
<ul class="org-ul">
<li><p>
<code>[ SENTFORM₁ | SENTFORM₂ | ... | SENTFORMₖ ]</code> refers to an optional
collection of alternatives of a sentential form.  For example, we
can represent an integer by the following specification:
</p>
<pre class="example">
&lt;int&gt;    ::= [ - ] &lt;digits&gt;
&lt;digits&gt; ::= &lt;digit&gt; | &lt;digit&gt; &lt;digits&gt;
&lt;digit&gt;  ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
</pre></li>
<li><p>
<code>( SENTFORM₁ | SENTFORM₂ | ... | SENTFORMₖ )</code> refers to a collection
of alternatives <i>within</i> a sentential form.  For example, we can
represent arithmetic expressions by the following specification:
</p>
<pre class="example">
&lt;expr&gt;   ::= &lt;expr&gt; ( + | - | * | / ) &lt;expr&gt; | &lt;digits&gt;
&lt;digits&gt; ::= &lt;digit&gt; | &lt;digit&gt; &lt;digits&gt;
&lt;digit&gt;  ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
</pre></li>
<li><p>
<code>{ SENTFORM₁ | SENTFORM₂ | ... | SENTFORMₖ }</code> refers to zero or
more occurrences of the sentential forms in a collection of
alternatives. For example, we can simplify the specification for
integers (and enforce that the first digit must be nonzero):
</p>
<pre class="example">
&lt;int&gt; ::= [ - ] ( 1 | ... | 9) { 0 | ... | 9 }
</pre></li>
</ul>
</div>
</div>
<div id="outline-container-orgb5a6bb6" class="outline-4">
<h4 id="orgb5a6bb6"><span class="section-number-4">2.1.3.</span> Exercises</h4>
<div class="outline-text-4" id="text-2-1-3">
<ol class="org-ol">
<li><p>
List the symbols (both terminal and nonterminal) implicit in the following specification.
</p>
<pre class="example">
&lt;a&gt; ::= a &lt;b&gt; | a &lt;a&gt; b
&lt;b&gt; ::= c &lt;a&gt; | d
</pre></li>
<li>Give a leftmost derivation of <code>a a a c a d b b</code> in the above
grammar. Draw its associated parse tree.</li>
<li>Verify that <code>a = a + a ; b = b</code> is recognized by the grammar for
the simple imperative language above.  Give a derivation that is
<i>not</i> leftmost.</li>
<li><p>
Implement the function
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">'a tree</span>
  = <span style="color: #000000; background-color: #ffffff;">Leaf</span> <span style="color: #a020f0;">of</span> 'a
  | <span style="color: #000000; background-color: #ffffff;">Node</span> <span style="color: #a020f0;">of</span> 'a tree list

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">frontier</span> (<span style="color: #a0522d;">t</span> :<span style="color: #228b22;"> 'a tree</span>) :<span style="color: #228b22;"> 'a list </span>=
  <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">TODO</span><span style="color: #b22222;"> *)</span>
</pre>
</div>
<p>
which returns a list of the members of <code>t</code> in order from left to
right.
</p></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org888316c" class="outline-3">
<h3 id="org888316c"><span class="section-number-3">2.2.</span> Ambiguity</h3>
<div class="outline-text-3" id="text-2-2">
<p>
A BNF specification is <b>ambiguous</b> if there is a sentence with
multiple parse trees.  Equivalently, a specification is ambiguous if
there is a sentence with multiple leftmost derivations.  We try to
avoid ambiguous specifications for programming languages because we ultimately
don't want a program to be interpretable in multiple ways.
</p>
</div>
<div id="outline-container-orgad96c05" class="outline-4">
<h4 id="orgad96c05"><span class="section-number-4">2.2.1.</span> Fixity</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
The <b>fixity</b> of an operator refers to where the operator is written
with respect to its arguments.
</p>
<ul class="org-ul">
<li><b>prefix</b> operators appear <i>before</i> their argument
<ul class="org-ul">
<li>the negation operator: <code>-5</code></li>
</ul></li>
<li><b>postfix</b> operators appear <i>after</i> their argument
<ul class="org-ul">
<li>type constructors: <code>int list</code></li>
</ul></li>
<li><b>infix</b> (binary) operators appear <i>between</i> their arguments
<ul class="org-ul">
<li>arithmetic operators: <code>(1 + 2) * (3 + 4)</code>)</li>
</ul></li>
<li><b>mixfix</b> operators are a combination of these
<ul class="org-ul">
<li>if-else-expressions: <code>if not b the f x else g x</code></li>
</ul></li>
</ul>

<p>
If a language's syntactic constructs are all prefix (<b>Polish notation</b>)
or all postfix (<b>reverse Polish notation</b>) then the specification is
unambiguous.  We can make infix binary operators unambiguous by
specifying their associativity and precedence.
</p>
</div>
</div>
<div id="outline-container-org7821e61" class="outline-4">
<h4 id="org7821e61"><span class="section-number-4">2.2.2.</span> Associativity</h4>
<div class="outline-text-4" id="text-2-2-2">
<p>
An operator \(\square\) is declared <b>left associative</b> if we interpret
\(a \square b \square c\) as \((a \square b) \square c\).
</p>
<ul class="org-ul">
<li>For arithmetic expressions, we take subtraction to be
left-associative, so the expression <code>1 - 2 - 3</code> evaluates to <code>-4</code>
as opposed to <code>2</code>.</li>
</ul>

<p>
An operator \(\square\) is declared <b>right associative</b> if we interpret
\(a \square b \square c\) as  \(a \square (b \square c)\).
</p>
<ul class="org-ul">
<li>For arithmetic expressions, we take exponentiation to be
right-associative, so the expression <code>2 ^ 1 ^ 3</code> evaluates to <code>2</code>
as opposed to <code>8</code>.</li>
</ul>

<p>
The associativity of an operator should affect the shape of parse tree
in a given grammar. For example, in the grammar:
</p>
<pre class="example">
&lt;expr&gt; ::= x | &lt;expr&gt; + &lt;expr&gt;
</pre>
<p>
there are two parse trees for the sentence <code>x + x + x</code>:
</p>
<pre class="example">
&lt;expr&gt;                                  &lt;expr&gt;
|                                       |
|---------------------------\           |------------ \
|                    |      |           |      |      |
&lt;expr&gt;               |      |           |      |      &lt;expr&gt;
|                    |      |           |      |      |
|-------------\      |      |           |      |      |-------------\
|      |      |      |      |           |      |      |      |      |
&lt;expr&gt; |      &lt;expr&gt; |      &lt;expr&gt;      &lt;expr&gt; |      &lt;expr&gt; |      &lt;expr&gt;
|      |      |      |      |           |      |      |      |      |
x      +      x      +      x           x      +      x      +      x
</pre>
<p>
The left tree groups the first two arguments (left associatively) and
the second groups the last two arguments (right associatively).
</p>

<p>
We can enforce the associativity of an operator in the specification
itself by breaking symmetry in the production rules, effectively
choosing one of the above two parse trees.  Addition is typically
understood as left associative, so we should require its <i>right</i>
argument to be a variable:
</p>

<pre class="example">
&lt;expr&gt; ::= x | &lt;expr&gt; + x
</pre>
</div>
</div>

<div id="outline-container-orgac17462" class="outline-4">
<h4 id="orgac17462"><span class="section-number-4">2.2.3.</span> Precedence</h4>
<div class="outline-text-4" id="text-2-2-3">
<p>
Given two binary operators \(\square\) and \(\triangle\), the operator
\(\square\) has <b>higher precedence</b> than \(\triangle\) if we interpret \(a
\square b \triangle c\) as \((a \square b) \triangle c\) and \(a \triangle
b \square c\) as \(a \triangle (b \square c)\).
</p>
<ul class="org-ul">
<li>For arithmetic expressions, we take multiplication to have higher
precedence than addition, so the expression <code>2 * 2 + 3</code> evaluates to
<code>7</code> as opposed to <code>10</code>.</li>
</ul>

<p>
As with associativity, we can enforce precedence within the
specification itself. In the grammar:
</p>
<pre class="example">
&lt;expr&gt; ::= x | &lt;expr&gt; + x | &lt;expr&gt; * x
</pre>
<p>
the sentences <code>x + x * x</code> has only one parse tree, but is not the
correct parse tree with respect to the rules of arithmetic (addition
has been given higher precedence).
</p>
<pre class="example">
&lt;expr&gt;
|
|---------------------------\
|                    |      |
&lt;expr&gt;               |      |
|                    |      |
|-------------\      |      |
|      |      |      |      |
&lt;expr&gt; |      |      |      |
|      |      |      |      |
x      +      x      *      x
</pre>
<p>
To fix this, we can break symmetry again by ensuring that arguments to
multiplication can only be variables or other expressions with only
multiplication.
</p>
<pre class="example">
&lt;expr&gt;  ::= &lt;expr2&gt; | &lt;expr&gt; + &lt;expr2&gt;
&lt;expr2&gt; ::= x | &lt;expr2&gt; * x
</pre>
<p>
In this grammar, the parse tree of <code>x + x * x</code> groups the arguments of
multiplication (giving multiplication higher precedence).
</p>
<pre class="example">
&lt;expr&gt;
|
|------------- \
|       |      |
&lt;expr&gt;  |      &lt;expr2&gt;
|       |      |
|       |      |--------------\
|       |      |       |      |
&lt;expr2&gt; |      &lt;expr2&gt; |      |
|       |      |       |      |
x       +      x       *      x
</pre>
<p>
Note that it is now impossible to group the argument of the addition.
In order to make this possible, parentheses need to be introduced into
the grammar:
</p>
<pre class="example">
&lt;expr&gt;  ::= &lt;expr2&gt; | &lt;expr&gt; + &lt;expr2&gt;
&lt;expr2&gt; ::= x | &lt;expr2&gt; * x | ( &lt;expr&gt; )
</pre>
</div>
</div>

<div id="outline-container-org74061c5" class="outline-4">
<h4 id="org74061c5"><span class="section-number-4">2.2.4.</span> Exercises</h4>
<div class="outline-text-4" id="text-2-2-4">
<ol class="org-ol">
<li>Draw the parse tree for the sentence <code>(x + x) * x</code> in the grammar
at the end of the section.</li>
<li>Draw the parse tree for the sentence <code>x * x + x * x</code> in the grammar
at the end of the section.</li>
<li>Update the grammar at the end of the section to include
subtraction, multiplication, and (right-associative)
exponentiation.</li>
<li><p>
Consider the following ambiguous grammar.
</p>
<pre class="example">
&lt;s&gt;  ::= &lt;np&gt; &lt;vp&gt;
&lt;vp&gt; ::= &lt;v&gt; | &lt;v&gt; &lt;np&gt; | &lt;v&gt; &lt;np&gt; &lt;pp&gt;
&lt;pp&gt; ::= &lt;p&gt; &lt;np&gt;
&lt;np&gt; ::= &lt;n&gt; | &lt;d&gt; &lt;n&gt; | &lt;np&gt; &lt;pp&gt;
&lt;n&gt;  ::= John | man | mountain | telescope
&lt;v&gt;  ::= saw
&lt;d&gt;  ::= the
&lt;p&gt;  ::= on | with
</pre>
<p>
Give two leftmost derivations of the sentence <code>John saw the man on
   the mountain with the telescope</code>.
</p></li>
<li><p>
Consider the following grammar for function types over <code>int</code>.
</p>
<pre class="example">
&lt;fun-type&gt; ::= &lt;int-type&gt; | &lt;fun-type&gt; -&gt; &lt;fun-type&gt;
&lt;int-type&gt; ::= int
</pre>
<p>
Show that this grammar is ambiguous and then rewrite this grammar
so that <code>-&gt;</code> is a right associative operator.
</p></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org357dc06" class="outline-3">
<h3 id="org357dc06"><span class="section-number-3">2.3.</span> Regular Grammars</h3>
<div class="outline-text-3" id="text-2-3">
<p>
A <b>(right linear) regular grammar</b> is a grammar such that every rule is in one of the following forms:
</p>
<pre class="example">
&lt;nonterm&gt; ::= term
&lt;nonterm&gt; ::= term &lt;nonterm&gt;
&lt;nonterm&gt; ::= ϵ
</pre>
<p>
where \(\epsilon\) refers to the empty sentence.
</p>

<p>
<b>Regular expressions</b> are a compact syntax for regular grammars.<sup><a id="fnr.6" class="footref" href="#fn.6" role="doc-backlink">6</a></sup>  They are defined
inductively as follows:
</p>
<ul class="org-ul">
<li>a terminal symbol is a regular expression</li>
<li>\(\epsilon\) is a regular expression</li>
<li>if \(r_1, r_2, \dots, r_k\) are regular expressions then so are
\(r_1r_2 \dots r_k\) and \(r_1 \ | \ r_2 \ | \ \dots \ | \ r_k\)</li>
<li>if \(r\) is a regular expression, then so is \((r)\) and \(r^*\)</li>
</ul>

<p>
A regular expression <b>accepts</b> or <b>recognizes</b> a sentence according to the following rules:
</p>
<ul class="org-ul">
<li>a terminal symbol \(t\) accepts \(t\)</li>
<li>if each \(r_i\) excepts \(s_i\), then \(r_1r_2\dots r_k\) accepts \(s_1s_2\dots s_k\)</li>
<li>if \(r_i\) accepts \(s_i\) then, \(r_1 \ | \ r_2 \ | \ \dots \ | \ r_k\)
accepts \(s_i\)</li>
<li>if \(r\) accepts \(s\) the \((r)\) accepts \(s\)</li>
<li>if \(r\) accepts \(s_1, s_2, \dots, s_k\), then \(r^*\) accepts \(s_1s_2
  \dots s_k\)</li>
</ul>
</div>

<div id="outline-container-org66b6711" class="outline-4">
<h4 id="org66b6711"><span class="section-number-4">2.3.1.</span> Exercises</h4>
<div class="outline-text-4" id="text-2-3-1">
<ol class="org-ol">
<li>Find a regular expression for all binary strings in which every <code>1</code>
is adjacent to <i>exactly</i> one other <code>1</code>.</li>
<li>Write a right-linear regular grammar for all binary strings in
which every <code>1</code> must be followed by <i>at least</i> two <code>0</code>'s. Give a
derivation in this grammar of the sentence <code>100100010000</code>.</li>
<li>Determine which of the following sentences are accepted by the
regular expression <code>a(bc|cb)*d</code>.
<ul class="org-ul">
<li><code>abc</code></li>
<li><code>abcd</code></li>
<li><code>abccbd</code></li>
<li><code>abad</code></li>
<li><code>abbcd</code></li>
</ul></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgcbe1079" class="outline-3">
<h3 id="orgcbe1079"><span class="section-number-3">2.4.</span> Chomsky Normal Form</h3>
<div class="outline-text-3" id="text-2-4">
<p>
A grammar is in <b>Chomsky normal form</b> if its rule are all of the
following forms:
</p>
<pre class="example">
&lt;start&gt;   ::= ϵ
&lt;nonterm&gt; ::= &lt;nonterm&gt; &lt;nonterm&gt;
&lt;nonterm&gt; ::= term
</pre>

<p>
Every grammar we have considered (i.e., every grammar with a BNF
specification) can be converted into an equivalent grammar (i.e., one
which accepts the same sentences) which is in Chomsky normal form.
</p>
</div>

<div id="outline-container-org4387632" class="outline-4">
<h4 id="org4387632"><span class="section-number-4">2.4.1.</span> Exercises</h4>
<div class="outline-text-4" id="text-2-4-1">
<ol class="org-ol">
<li><p>
Rewrite the following grammar in Chomsky normal form.
</p>
<pre class="example">
&lt;a&gt; ::= a &lt;b&gt; b
&lt;b&gt; ::= &lt;b&gt; c | &lt;c&gt; &lt;c&gt;
&lt;c&gt; ::= &lt;c&gt; d | d &lt;c&gt;
</pre></li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc2d0547" class="outline-2">
<h2 id="orgc2d0547"><span class="section-number-2">3.</span> Parsing</h2>
<div class="outline-text-2" id="text-3">
<p>
The general parsing problem is to find a derivation of a sentence in a
given grammar, if one exists.<sup><a id="fnr.7" class="footref" href="#fn.7" role="doc-backlink">7</a></sup>
</p>

<p>
In the context of this course, we are primarily interested in the
specific problem of converting a <code>string</code> (or <code>char list</code>) into an ADT
representing the syntax of the program.
</p>

<p>
There are many ways to accomplish this, we saw two:
<b>recursive-descent</b> and <b>parser-combinators</b>.
</p>

<p>
Recursive-descent parsing is an ad-hoc parsing method in which
mutually recursive functions are defined to parse each part of a given
specification. <b>It will not appear on the final exam in any
significant way.</b>
</p>
</div>
<div id="outline-container-org6a444d1" class="outline-3">
<h3 id="org6a444d1"><span class="section-number-3">3.1.</span> Combinators</h3>
<div class="outline-text-3" id="text-3-1">
<p>
We can think of a parser for <code>'a</code>'s as a function of type
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">'a parser</span> = char list -&gt; ('a * char list) option
</pre>
</div>
<p>
which
</p>
<ol class="org-ol">
<li>consumes the prefix of the input stream corresponding to an <code>'a</code>,</li>
<li>converts that prefix to an <code>'a</code>, and finally,</li>
<li>returns that <code>'a</code> and the remainder of the stream, failing if no
initial part of the stream corresponds to an <code>'a</code>.</li>
</ol>

<p>
One of the simplest examples is the <code>char</code> parser:
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">char</span> (<span style="color: #a0522d;">d</span> :<span style="color: #228b22;"> char</span>) (<span style="color: #a0522d;">cs</span> :<span style="color: #228b22;"> char list</span>) :<span style="color: #228b22;"> (char * char list) option </span>=
  <span style="color: #a020f0;">match</span> cs <span style="color: #a020f0;">with</span>
  | c <span style="color: #000000; background-color: #ffffff;">::</span> cs <span style="color: #a020f0;">when</span> c = d -&gt; <span style="color: #000000; background-color: #ffffff;">Some</span> (d, cs)
  | _ -&gt; None
</pre>
</div>
<p>
which consumes the first character of <code>cs</code> given that it is equal to
<code>d</code> and returns it, along with the remainder of <code>cs</code>.  This parser
fails (returns <code>None</code>) in the case that the first character of <code>cs</code> is
not <code>d</code>.
</p>

<p>
When we want to <i>use</i> a parser, we apply it to a character list and
verify that it consumed it's the entire input:
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">parse</span> (<span style="color: #a0522d;">p</span> :<span style="color: #228b22;"> 'a parser</span>) (<span style="color: #a0522d;">s</span> :<span style="color: #228b22;"> string</span>) =
  <span style="color: #a020f0;">match</span> p (explode s) <span style="color: #a020f0;">with</span>
  | (a, <span style="color: #000000; background-color: #ffffff;">[]</span>) -&gt; <span style="color: #000000; background-color: #ffffff;">Some</span> a
  | _ -&gt; None
</pre>
</div>

<p>
A <b>parser combinator</b> is a higher-order function which can be used to
compose parsers. There is a small subset of parser combinators which
are of particular importance because they correspond to the constructs
in EBNF specifications and regular expressions.
</p>
<ul class="org-ul">
<li><p>
<b>Alternatives.</b> <code>p1 &lt;|&gt; p2</code> is the parser which tries running the
parser <code>p1</code>, returning its output if it succeeds, and runs <code>p2</code>
otherwise.
</p>

<p>
If <code>p1</code> is a parser for the forms of a nonterminal symbol <code>&lt;p1&gt;</code>
and <code>p2</code> a parser for forms of a nonterminal symbol <code>&lt;p2&gt;</code>, then <code>p1
  &lt;|&gt; p2</code> is a parser for forms of the nonterminal symbol
</p>
<pre class="example">
&lt;alt&gt; ::= &lt;p1&gt; | &lt;p2&gt;
</pre></li>
<li><p>
<b>Sequencing.</b> <code>seq p1 p2</code> is the parser which runs both <code>p1</code> and
<code>p2</code> and returns both of their outputs if both parsers succeed.  It
fails if either <code>p1</code> or <code>p2</code> fails.
</p>

<p>
If <code>p1</code> is a parser for the forms of a nonterminal symbol <code>&lt;p1&gt;</code> and
<code>p2</code> a parser for forms of a nonterminal symbol <code>&lt;p2&gt;</code>, then <code>seq p1
  p2</code> is a parser for forms of the nonterminal symbol
</p>
<pre class="example">
&lt;seq&gt; ::= &lt;p1&gt; &lt;p2&gt;
</pre></li>
<li><p>
<b>Repetition.</b> <code>many p</code> is the parser which runs <code>p</code> repeatedly until
it fails, collecting all its outputs in a list.
</p>

<p>
If <code>p</code> is a parser for the forms of a nonterminal symbol <code>&lt;p&gt;</code>, then <code>many
  p</code> is a parser for forms of the nonterminal symbol
</p>
<pre class="example">
&lt;many&gt; ::= { &lt;p&gt; }
</pre></li>
</ul>

<p>
The last important combinator is <code>map</code>, which can be used to
manipulate the output of a parser without affecting how it consumes
its input.  If <code>p</code> is an <code>'a parser</code>, and <code>f</code> is a function of type
<code>'a -&gt; 'b</code>, then <code>map f p</code> is a <code>'b parser</code> which runs <code>'a</code> and then
applies <code>f</code> to its output (if it succeeds).
</p>

<p>
You should also be familiar with how to use the more convenient parser
combinators throughout the course. <b>For the final exam, you will not
be required to memorize their definitions.</b>
</p>
<ul class="org-ul">
<li><code>str</code>, <code>token</code>, <code>ws</code></li>
<li>(<code>&gt;&gt;</code>), (<code>&lt;&lt;</code>), <code>seq3</code>, <code>seq4</code></li>
<li>(<code>&gt;|</code>), <code>map2</code>, <code>map3</code>, <code>map4</code></li>
<li><code>optional</code></li>
<li><code>pure</code>, <code>fail</code>, (we will not test on <code>bind</code> (<code>&gt;&gt;=</code>) but it is good to know&#x2026;)</li>
</ul>
</div>
<div id="outline-container-orgee0ca67" class="outline-4">
<h4 id="orgee0ca67"><span class="section-number-4">3.1.1.</span> Exercises</h4>
<div class="outline-text-4" id="text-3-1-1">
<ol class="org-ol">
<li><p>
Implement the parser
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a0522d;">parse_bool</span> :<span style="color: #228b22;"> bool </span><span style="color: #483d8b;">parser</span><span style="color: #228b22;"> </span>=
  <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">TODO</span><span style="color: #b22222;"> *)</span>
</pre>
</div>
<p>
which can consume <code>"True"</code> and return the value <code>tre</code> or <code>"False"</code>
and return the value false. In particular, it should not consume
whitespace before or <code>"True"</code> or <code>"False"</code>
</p></li>
<li><p>
Implement the parser
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a0522d;">parse_bool_list</span> :<span style="color: #228b22;"> bool list </span><span style="color: #483d8b;">parser</span><span style="color: #228b22;"> </span>=
  <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">TODO</span><span style="color: #b22222;"> *)</span>
</pre>
</div>
<p>
which can parse a list of booleans in Python syntax, i.e., square
brackets, comma separators, white-space agnostic.
</p></li>
<li><p>
Implement a parser
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a0522d;">peak</span> :<span style="color: #228b22;"> char </span><span style="color: #483d8b;">parser</span><span style="color: #228b22;"> </span>=
  <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">TODO</span><span style="color: #b22222;"> *)</span>
</pre>
</div>
<p>
which returns the first character of its input <i>but does not
consume any part of the input.</i> This should only fail if the input is empty.
</p></li>
<li><p>
Implement a parser combinator
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">check</span> (<span style="color: #a0522d;">p</span> :<span style="color: #228b22;"> 'a parser</span>) (<span style="color: #a0522d;">pred</span> :<span style="color: #228b22;"> 'a -&gt; bool</span>) :<span style="color: #228b22;"> 'a </span><span style="color: #483d8b;">parser</span><span style="color: #228b22;"> </span>=
  <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">TODO</span><span style="color: #b22222;"> *)</span>
</pre>
</div>
<p>
which runs <code>p</code> and then fails if <code>pred</code> is false on the output of
<code>p</code>. <i>Hint.</i> It is easier to implement directly, rather than in
terms of other combinators.
</p></li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-orgf41e697" class="outline-2">
<h2 id="orgf41e697"><span class="section-number-2">4.</span> Formal Semantics</h2>
<div class="outline-text-2" id="text-4">
<p>
Semantics is the study of the <i>meaning</i> of language.  We use concepts
from formal semantics to model the meaning of programs.
</p>

<p>
We discussed two forms of semantics: <b>denotational</b> and <b>operational</b>.
</p>

<p>
Giving a denotational semantics for a programming language means
assigning to each program a <i>mathematical function</i> which has the same
input/output behavior as the program.
</p>

<p>
We focused primarily on operational semantics.  Giving an operational
semantics for a programming language means describing how a program is
evaluated.  This typically means defining a <b>reduction relation</b> on
programs, which describes how a program is reduced until it reaches a
state which cannot be further reduced.
</p>
</div>
<div id="outline-container-org82b08a8" class="outline-3">
<h3 id="org82b08a8"><span class="section-number-3">4.1.</span> Derivations</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Suppose we have a programming language defined by a BNF specification
\(\mathcal P\).
</p>

<p>
A <b>configuration</b> is a pair consistent of a program \(P\) (a sentence
accepted by \(\mathcal P\)) and a state \(S\) which may be manipulated by
programs.  The nature of \(S\) depends on the intentions of the
programming language.  The state may be empty, as in the case of
functional languages.
</p>

<p>
Defining a (small-step) operational semantics means defining a
reduction relation for configurations:
</p>

\begin{equation*}
( \ S \ , \ P \ ) \longrightarrow ( \ S' \ , \ P' \ )
\end{equation*}

<p>
A reduction relation is defined via <b>reduction rules</b>, which
consist of a <i>shape</i> of a reduction together with a collection of
<b>premises</b>, which may be other shapes of reductions or trivial premises
(also called <b>axioms</b>). The general form of a reduction rules is:
</p>

\begin{prooftree}
\AxiomC{$P_1$}
\AxiomC{$P_2$}
\AxiomC{$\dots$}
\AxiomC{$P_k$}
\RightLabel{(name)}
\QuaternaryInfC{$C \longrightarrow C'$}
\end{prooftree}

<p>
<i>Shape</i> here refers to the fact that the configurations in a reduction
rule contains <i>meta-variables</i> that describe the <i>kind of reductions</i>
that can be derived, or that can be used a premises.  For example, the
rules for evaluating an arithmetic expression might include
</p>

\begin{prooftree}
\AxiomC{$e_1 \longrightarrow e_1'$}
\RightLabel{(addLeft)}
\UnaryInfC{$e_1 + e_2 \longrightarrow e_1' + e_2$}
\end{prooftree}

<p>
which expresses that if \(e_1\) reduces to \(e_1'\) in a single step then
\(e_1 + e_2\) reduces to \(e_1' + e_2\) in a single step <i>no matter the
expressions \(e_1\), \(e_1'\) and \(e_2\)</i>.  This rule can be used to show that
</p>

\begin{equation*}
(1 + 2) + 3 \longrightarrow 3 + 3
\end{equation*}

<p>
but also that
</p>

\begin{equation*}
(1 + (4 - 2)) + 3 \longrightarrow (1 + 2) + 3
\end{equation*}

<p>
Both reductions invoke that fact that if the left argument can be
reduced by a single step, then the sum can be reduced by a single
step.
</p>

<p>
A <b>derivation</b> is, informally, a tree in which each node is a
reduction and the children of a node are the premises required to
derive that reduction according to a reduction rule.  The leaves of a
derivation are trivial premises.  A derivation of a reduction \(C
\longrightarrow C'\) is a derivation whose root is \(C \longrightarrow
C'\).
</p>

<p>
What we have been describing is a <b>single-step reduction relation</b>.
Any single-step reduction relation can be extended to a <b>multi-step
reduction relation</b> by including the following rules and a multi-step
reduction relation symbol '\(\longrightarrow^{\star}\)'.
</p>

\begin{equation*}
\begin{prooftree}
\AxiomC{}
\RightLabel{(refl)}
\UnaryInfC{$C \longrightarrow^\star C$}
\end{prooftree}
\qquad
\begin{prooftree}
\AxiomC{$C \longrightarrow^\star C'$}
\AxiomC{$C' \longrightarrow C''$}
\RightLabel{(trans)}
\BinaryInfC{$C \longrightarrow^\star C''$}
\end{prooftree}
\end{equation*}

<p>
Formally, <b>evaluation</b> is the process of determining a configuration
\(C'\) for a given configuration \(C\) such that \(C \longrightarrow^\star
C'\) and \(C'\) cannot be further reduced (i.e., there is no other
configuration \(C''\) such that \(C' \longrightarrow C''\)).
</p>

<p>
We can express an evaluation as a derivation of a multi-step
reduction, but it is common (and done below) to simply write a
sequence of configurations, with the understanding that each
configuration follows from the previous configuration by a derivable
single-step reduction.
</p>
</div>
</div>
<div id="outline-container-org0a23acb" class="outline-3">
<h3 id="org0a23acb"><span class="section-number-3">4.2.</span> Examples</h3>
<div class="outline-text-3" id="text-4-2">
<p>
There are many examples of operational semantics and reduction rules
in this document, we start with the two most basic.
</p>
</div>
<div id="outline-container-orgad1f3d4" class="outline-4">
<h4 id="orgad1f3d4"><span class="section-number-4">4.2.1.</span> Arithmetic Expressions</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
In the operational semantics of arithmetic expressions, we take a
configuration to be an arithmetic expression (a program with no
state).  Each rule describes how to reduce an arithmetic expression by
a single step.
</p>

<hr />

<p>
<i>Grammar for a subset of arithmetic expressions in Polish notation:</i>
</p>

<pre class="example">
&lt;expr&gt;  ::= &lt;num&gt; | (add | sub) &lt;expr&gt; &lt;expr&gt;
&lt;num&gt;   ::= [-] (0 | ... | 9) | { 0 | ... | 9 }
</pre>

<hr />
<p>
<i>Operational semantics for a subset of arithmetic expression in
Polish notation:</i>
</p>

\begin{prooftree}
\AxiomC{$m \in \mathbb Z$}
\AxiomC{$n \in \mathbb Z$}
\RightLabel{(addNum)}
\BinaryInfC{$\mathsf{add} \ m \ n \longrightarrow m + n$}
\end{prooftree}

\begin{equation*}
\begin{prooftree}
\AxiomC{$e_1 \longrightarrow e_1'$}
\RightLabel{(addLeft)}
\UnaryInfC{$\textsf{add} \ e_1 \ e_2 \longrightarrow \mathsf{add} \ e_1' \ e_2$}
\end{prooftree}
\qquad
\begin{prooftree}
\AxiomC{$e_2 \longrightarrow e_2'$}
\RightLabel{(addRight)}
\UnaryInfC{$\mathsf{add} \ e_1 \ e_2 \longrightarrow \mathsf{add} \ e_1 \ e_2'$}
\end{prooftree}
\end{equation*}

\begin{prooftree}
\AxiomC{$m \in \mathbb Z$}
\AxiomC{$n \in \mathbb Z$}
\RightLabel{(subNum)}
\BinaryInfC{$\mathsf{sub} \ m \ n \longrightarrow m - n$}
\end{prooftree}

\begin{equation*}
\begin{prooftree}
\AxiomC{$e_1 \longrightarrow e_1'$}
\RightLabel{(subLeft)}
\UnaryInfC{$\textsf{sub} \ e_1 \ e_2 \longrightarrow \mathsf{sub} \ e_1' \ e_2$}
\end{prooftree}
\qquad
\begin{prooftree}
\AxiomC{$e_2 \longrightarrow e_2'$}
\RightLabel{(subRight)}
\UnaryInfC{$\mathsf{sub} \ e_1 \ e_2 \longrightarrow \mathsf{sub} \ e_1 \ e_2'$}
\end{prooftree}
\end{equation*}

<hr />

<p>
It is generally preferable that any derivable reduction
has a <i>unique</i> derivation.  This makes defining an evaluation procedure
easier, and amounts to fixing an <b>evaluation order</b>.  We can enforce
an evaluation order via the structure of our reduction rules.
</p>

<hr />
<p>
<i>Operational semantics for a subset of arithmetic expression in
Polish Notation with a left-to-right evaluation order:</i>
</p>

\begin{prooftree}
\AxiomC{$m \in \mathbb Z$}
\AxiomC{$n \in \mathbb Z$}
\RightLabel{(addNum)}
\BinaryInfC{$\mathsf{add} \ m \ n \longrightarrow m + n$}
\end{prooftree}

\begin{equation*}
\begin{prooftree}
\AxiomC{$e_1 \longrightarrow e_1'$}
\RightLabel{(addLeft)}
\UnaryInfC{$\textsf{add} \ e_1 \ e_2 \longrightarrow \mathsf{add} \ e_1' \ e_2$}
\end{prooftree}
\qquad
\begin{prooftree}
\AxiomC{$m \in \mathbb Z$}
\AxiomC{$e_2 \longrightarrow e_2'$}
\RightLabel{(addRight)}
\BinaryInfC{$\mathsf{add} \ m \ e_2 \longrightarrow \mathsf{add} \ m \ e_2'$}
\end{prooftree}
\end{equation*}

\begin{prooftree}
\AxiomC{$m \in \mathbb Z$}
\AxiomC{$n \in \mathbb Z$}
\RightLabel{(subNum)}
\BinaryInfC{$\mathsf{sub} \ m \ n \longrightarrow m - n$}
\end{prooftree}

\begin{equation*}
\begin{prooftree}
\AxiomC{$e_1 \longrightarrow e_1'$}
\RightLabel{(subLeft)}
\UnaryInfC{$\textsf{sub} \ e_1 \ e_2 \longrightarrow \mathsf{sub} \ e_1' \ e_2$}
\end{prooftree}
\qquad
\begin{prooftree}
\AxiomC{$m \in \mathbb Z$}
\AxiomC{$e_2 \longrightarrow e_2'$}
\RightLabel{(subRight)}
\BinaryInfC{$\mathsf{sub} \ m \ e_2 \longrightarrow \mathsf{sub} \ m \ e_2'$}
\end{prooftree}
\end{equation*}

<hr />
<p>
<i>Example single-step derivation:</i>
</p>

\begin{equation}\label{d1}
\begin{prooftree}
\AxiomC{$2 \in \mathbb Z$}
\AxiomC{$3 \in \mathbb Z$}
\BinaryInfC{$\mathsf{sub} \ 2 \ 3 \longrightarrow \text{-} 1$}
\UnaryInfC{$\mathsf{add} \ \mathsf{sub} \ 2 \ 3 \ \mathsf{add} \ 1 \ 1 \longrightarrow \mathsf{add} \ \text{-}1 \ \mathsf{add} \ 1 \ 1$}
\end{prooftree}
\end{equation}

<hr />
<p>
<i>Example multi-step derivation:</i>
</p>

\begin{equation}\label{d2}
\begin{prooftree}
\AxiomC{$\text - 1 \in \mathbb Z$}
\AxiomC{$1 \in \mathbb Z$}
\AxiomC{$1 \in \mathbb Z$}
\BinaryInfC{$\mathsf{add} \ 1 \ 1 \longrightarrow 2$}
\BinaryInfC{$\mathsf{add} \ \text - 1 \ \mathsf{add} \ 1 \ 1 \longrightarrow \mathsf{add} \ \text- 1 \ 2$}
\end{prooftree}
\end{equation}

\begin{equation}\label{d3}
\begin{prooftree}
\AxiomC{$\text- 1 \in \mathbb Z$}
\AxiomC{$2 \in \mathbb Z$}
\BinaryInfC{$\mathsf{add} \ \text- 1 \ 2 \longrightarrow 1$}
\end{prooftree}
\end{equation}

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\mathsf{add} \ \mathsf{sub} \ 2 \ 3 \ \mathsf{add} \ 1 \ 1 \longrightarrow^\star \mathsf{add} \ \mathsf{sub} \ 2 \ 3 \ \mathsf{add} \ 1 \ 1$}
\AxiomC{(\ref{d1})}
\BinaryInfC{$\mathsf{add} \ \mathsf{sub} \ 2 \ 3 \ \mathsf{add} \ 1 \ 1 \longrightarrow^\star \mathsf{add} \ \text{-}1 \ \mathsf{add} \ 1 \ 1$}
\AxiomC{(\ref{d2})}
\BinaryInfC{$\mathsf{add} \ \mathsf{sub} \ 2 \ 3 \ \mathsf{add} \ 1 \ 1 \longrightarrow^\star \mathsf{add} \ \text{-}1 \ 2$}\
\AxiomC{(\ref{d3})}
\BinaryInfC{$\mathsf{add} \ \mathsf{sub} \ 2 \ 3 \ \mathsf{add} \ 1 \ 1 \longrightarrow^\star 1$}\
\end{prooftree}

<hr />
<p>
<i>Example evaluation, written as a sequence of configurations:</i>
</p>
<pre class="example">
add sub 2 3 add 1 1 ⟶
add -1 add 1 1 ⟶
add -1 2 ⟶
1 ✓
</pre>
</div>
</div>
<div id="outline-container-org8484db2" class="outline-4">
<h4 id="org8484db2"><span class="section-number-4">4.2.2.</span> A Stack-Oriented Language</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
The primary examples we used in this course for understanding
operational semantics were variants of stack-oriented
languages.<sup><a id="fnr.8" class="footref" href="#fn.8" role="doc-backlink">8</a></sup>
</p>

<p>
In the simplest case, we take a configuration to be a program (\(P\))
together with a stack of integers (\(S\)), written
</p>

\begin{equation*}
( \ S \ , \ P \ )
\end{equation*}

<p>
We also include a special irreducible configuration \(\mathsf{ERROR}\)
for representing a failed evaluation.
</p>

<hr />
<p>
<i>Grammar for a simple stack-oriented language:</i>
</p>
<pre class="example">
&lt;prog&gt;  ::= { &lt;com&gt; }
&lt;com&gt;   ::= push &lt;num&gt; | dup | add | sub
          | then &lt;prog&gt; else &lt;prog&gt; end
&lt;num&gt;   ::= (0 | ... | 9) { 0 | ... | 9 }
</pre>

<hr />
<p>
<i>Example program which puts 14 + 15 - 16 on the stack:</i>
</p>
<pre class="example">
push 16 push 15 push 14
add sub
</pre>

<hr />
<p>
<i>Operational semantics for a simple stack-oriented language:</i>
</p>

\begin{prooftree}
\AxiomC{}
\RightLabel{(push)}
\UnaryInfC{$(\ S \ , \ \textsf{push n} \ P \ ) \longrightarrow ( \ n :: S \ ,\ P \ )$}
\end{prooftree}

\begin{equation*}
\begin{prooftree}
\AxiomC{}
\RightLabel{(dup)}
\UnaryInfC{$( \ n :: S \ , \ \textsf{dup} \ P \ ) \longrightarrow
  ( \ n :: n :: S \ , \ P \ )$}
\end{prooftree}
\qquad
\begin{prooftree}
\AxiomC{}
\RightLabel{(dupErr)}
\UnaryInfC{$( \ \varnothing \ , \ \textsf{dup} \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}
\end{equation*}

\begin{prooftree}
\AxiomC{}
\RightLabel{(add)}
\UnaryInfC{$( \ m :: n :: S \ , \ \textsf{add} \ P \ ) \longrightarrow ( \ (m + n) :: S \ , \ P \ )$}
\end{prooftree}

\begin{equation*}
\begin{prooftree}
\AxiomC{}
\RightLabel{(addErr1)}
\UnaryInfC{$( \ n :: S \ , \ \mathsf{add} \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}
\qquad
\begin{prooftree}
\AxiomC{}
\RightLabel{(addErr0)}
\UnaryInfC{$( \ \varnothing \ , \ \mathsf{add} \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}
\end{equation*}

\begin{prooftree}
\AxiomC{}
\RightLabel{(sub)}
\UnaryInfC{$( \ m :: n :: S \ , \ \textsf{sub} \ P \ ) \longrightarrow ( \ (m - n) :: S \ , \ P \ )$}
\end{prooftree}

\begin{equation*}
\begin{prooftree}
\AxiomC{}
\RightLabel{(subErr1)}
\UnaryInfC{$( \ n :: S \ , \ \mathsf{sub} \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}
\qquad
\begin{prooftree}
\AxiomC{}
\RightLabel{(subErr0)}
\UnaryInfC{$( \ \varnothing \ , \ \mathsf{sub} \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}
\end{equation*}

\begin{prooftree}
\AxiomC{}
\RightLabel{(ifFalse)}
\UnaryInfC{$( \ 0 :: S \ , \ \textsf{then} \ Q_1 \ \textsf{else} \ Q_2 \ \textsf{end} \ P \ ) \longrightarrow
( \ S \ , \ Q_2 \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$n \not = 0$}
\RightLabel{(ifTrue)}
\UnaryInfC{$( \ n :: S \ , \ \textsf{then} \ Q_1 \ \textsf{else} \ Q_2 \ \textsf{end} \ P \ ) \longrightarrow
( \ S \ , \ Q_1 \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(ifErr)}
\UnaryInfC{$( \ \varnothing \ , \ \textsf{then} \ Q_1 \ \textsf{else} \ Q_2 \ \textsf{end} \ P \ ) \longrightarrow
\mathsf{ERROR}$}
\end{prooftree}

<hr />
<p>
<i>Example multi-step derivation:</i>
</p>

\begin{equation}\label{e1}
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$
( \ \varnothing \ , \ \textsf{push 16 push 15 push 14 add sub} \ )
\longrightarrow
( \ 16 :: \varnothing \ , \ \textsf{push 15 push 14 add sub} \ )
$}
\end{prooftree}
\end{equation}

\begin{equation}\label{e2}
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$
( \ 16 :: \varnothing \ , \ \textsf{push 15 push 14 add sub} \ )
\longrightarrow
( \ 15 :: 16 :: \varnothing \ , \ \textsf{push 14 add sub} \ )
$}
\end{prooftree}
\end{equation}

\begin{equation}\label{e3}
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$
( \ 15 :: 16 :: \varnothing \ , \ \textsf{push 14 add sub} \ )
\longrightarrow
( \ 14 :: 15 :: 16 :: \varnothing \ , \ \textsf{add sub} \ )
$}
\end{prooftree}
\end{equation}

\begin{equation}\label{e4}
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$
( \ 14 :: 15 :: 16 :: \varnothing \ , \ \textsf{add sub} \ )
\longrightarrow
( \ 29 :: 16 :: \varnothing \ , \ \textsf{sub} \ )
$}
\end{prooftree}
\end{equation}

\begin{equation}\label{e5}
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$
( \ 29 :: 16 :: \varnothing \ , \ \textsf{sub} \ )
\longrightarrow
( \ 13 :: \varnothing \ , \ \epsilon \ )
$}
\end{prooftree}
\end{equation}

\begin{equation}\label{f1}
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$
( \ \varnothing \ , \ \textsf{push 16 push 15 push 14 add sub} \ )
\longrightarrow^\star
( \ \varnothing \ , \ \textsf{push 16 push 15 push 14 add sub} \ )
$}
\end{prooftree}
\end{equation}

\begin{equation}\label{f2}
\begin{prooftree}
\AxiomC{(\ref{f1})}
\AxiomC{(\ref{e1})}
\BinaryInfC{$
( \ \varnothing \ , \ \textsf{push 16 push 15 push 14 add sub} \ )
\longrightarrow^\star
( \ 16 :: \varnothing \ , \ \textsf{push 15 push 14 add sub} \ )
$}
\end{prooftree}
\end{equation}

\begin{equation}\label{f3}
\begin{prooftree}
\AxiomC{(\ref{f2})}
\AxiomC{(\ref{e2})}
\BinaryInfC{$
( \ \varnothing \ , \ \textsf{push 16 push 15 push 14 add sub} \ )
\longrightarrow^\star
( \ 15 :: 16 :: \varnothing \ , \ \textsf{push 14 add sub} \ )
$}
\end{prooftree}
\end{equation}

\begin{equation}\label{f4}
\begin{prooftree}
\AxiomC{(\ref{f3})}
\AxiomC{(\ref{e3})}
\BinaryInfC{$
( \ \varnothing \ , \ \textsf{push 16 push 15 push 14 add sub} \ )
\longrightarrow^\star
( \ 14 :: 15 :: 16 :: \varnothing \ , \ \textsf{add sub} \ )
$}
\end{prooftree}
\end{equation}

\begin{equation}\label{f5}
\begin{prooftree}
\AxiomC{(\ref{f4})}
\AxiomC{(\ref{e4})}
\BinaryInfC{$
( \ \varnothing \ , \ \textsf{push 16 push 15 push 14 add sub} \ )
\longrightarrow^\star
( \ 29 :: 16 :: \varnothing \ , \ \textsf{sub} \ )
$}
\end{prooftree}
\end{equation}

\begin{prooftree}
\AxiomC{(\ref{f5})}
\AxiomC{(\ref{e5})}
\BinaryInfC{$
( \ \varnothing \ , \ \textsf{push 16 push 15 push 14 add sub} \ )
\longrightarrow^\star
( \ 13 :: \varnothing \ , \ \epsilon \ )
$}
\end{prooftree}

<hr />
<p>
<i>Example evaluation:</i>
</p>
<pre class="example">
( ∅                   , push 16 push 15 push 14 add sub ) ⟶
( 16 :: ∅             , push 15 push 14 add sub ) ⟶
( 15 :: 16 :: ∅       , push 14 add sub ) ⟶
( 14 :: 15 :: 16 :: ∅ , add sub ) ⟶
( 29 :: 16 :: ∅       , sub ) ⟶
( 13 :: ∅             , ϵ ) ✓
</pre>
</div>
</div>
<div id="outline-container-org8182372" class="outline-4">
<h4 id="org8182372"><span class="section-number-4">4.2.3.</span> Exercises</h4>
<div class="outline-text-4" id="text-4-2-3">
<ol class="org-ol">
<li>Add multiplication (<code>mul</code>) and division (<code>div</code>) to the operational semantics of
arithmetic expressions (make sure to disallow division by \(0\)).</li>
<li><p>
Derive the single-step reduction
</p>
<pre class="example">
sub add add 1 2 mul 3 4 2 ⟶ sub add 3 mul 3 4 2
</pre>
<p>
in the operational semantics for arithmetic expressions.
</p></li>
<li><p>
Derive the multi-step reduction
</p>
<pre class="example">
sub add add 1 2 mul 3 4 2 ⟶⋆ ??
</pre>
<p>
where <code>??</code> is the value of the given expression according to the
given semantics.  You may write it as a sequence of configurations.
</p></li>
<li>Write an operational semantics for Boolean expressions with
left-to-right evaluation and short-circuiting (like in project 3).</li>
<li><p>
Given an evaluation of the program
</p>
<pre class="example">
push 10 dup mul dup
</pre>
<p>
in the given semantics for the above stack-oriented language.
</p></li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-orgde01630" class="outline-2">
<h2 id="orgde01630"><span class="section-number-2">5.</span> Variables</h2>
<div class="outline-text-2" id="text-5">
<p>
When introducing variables into a programming language, we need to
introduce an <b>environment</b> to the configuration which maintains
variable bindings.
</p>

<p>
The structure of the environment depends on the scoping rules used in
the language, but in the simplest case, and environment is a mapping
of variable names to values.  This can be implemented as an
association list in OCaml.
</p>

<p>
No matter the implementation, an environment requires two operations:
<b>fetch</b> and <b>update</b>.  The fetch operation should get the value to
which a variable is bound in the environment, failing if the variable
is not bound in the environment.  The update operation should return a
new environment with the additional binding.
</p>

<hr />
<p>
<i>OCaml implementation of an environment represented as an association list:</i>
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">value</span> = unit <span style="color: #b22222;">(* </span><span style="color: #b22222;">A DUMMY TYPE</span><span style="color: #b22222;"> *)</span>
<span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">'a env</span> = ('a * value) list

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a0522d;">empty_env</span> = <span style="color: #000000; background-color: #ffffff;">[]</span>

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">fetch</span> (<span style="color: #a0522d;">e</span> :<span style="color: #228b22;"> 'a env</span>) (<span style="color: #a0522d;">x</span> :<span style="color: #228b22;"> 'a</span>) :<span style="color: #228b22;"> value option </span>=
  <span style="color: #228b22;">List.</span>assoc_opt x e

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">update</span>
  (<span style="color: #a0522d;">e</span> :<span style="color: #228b22;"> 'a env</span>)
  (<span style="color: #a0522d;">x</span> :<span style="color: #228b22;"> 'a</span>)
  (<span style="color: #a0522d;">v</span> :<span style="color: #228b22;"> value</span>) :<span style="color: #228b22;"> 'a env </span>=
  (x, v) <span style="color: #000000; background-color: #ffffff;">::</span> e
</pre>
</div>

<hr />

<p>
Again, different environment representations need different
implementations of fetch and update, but regardless of how these
functions are implemented, they should satisfy the following
equations:
</p>

<ul class="org-ul">
<li><code>fetch emtpy_env x = None</code> for any <code>x</code></li>
<li><code>fetch (update e x v) x = Some v</code> for any <code>e</code>, <code>x</code>, and <code>v</code></li>
<li><code>fetch (update e x v) y = fetch e y</code> for any <code>e</code>, <code>x</code>, <code>y</code>, and <code>v</code>
given <code>y</code> is not equal to <code>x</code></li>
</ul>
</div>
<div id="outline-container-orgc5c95d0" class="outline-3">
<h3 id="orgc5c95d0"><span class="section-number-3">5.1.</span> Stack-Oriented Language with Variables</h3>
<div class="outline-text-3" id="text-5-1">
<p>
In the operational semantics of the following stack-oriented language,
we take a configuration to be a program (\(P\)) together with a stack of
integers (\(S\)) and an environment \(E\) of variable bindings.
</p>

\begin{equation*}
( \ S \ , \ E \ , \ P \ )
\end{equation*}

<p>
As above, we also include the special irreducible configuration \(\mathsf{ERROR}\).
</p>

<hr />
<p>
<i>Grammar for a stack-oriented language with variables:</i>
</p>
<pre class="example">
&lt;prog&gt;  ::= { &lt;com&gt; }
&lt;com&gt;   ::= push &lt;num&gt; | dup | add | sub
          | then &lt;prog&gt; else &lt;prog&gt; end
          | lookup &lt;ident&gt; | assign &lt;ident&gt;
&lt;num&gt;   ::= ( 0 | ... | 9 ) { 0 | ... | 9 }
&lt;ident&gt; ::= ( A | ... | Z ) { A | ... | Z }
</pre>

<hr />
<p>
<i>Example program:</i>
</p>
<pre class="example">
push 14 assign X
push 15 assign Y
lookup X lookup Y add
</pre>

<hr />
<p>
<i>Operational semantics for a stack-oriented language with variables:</i>
</p>


\begin{prooftree}
\AxiomC{}
\RightLabel{(push)}
\UnaryInfC{$(\ S \ , \ E \ , \ \textsf{push n} \ P \ ) \longrightarrow ( \ n :: S \ , \ E \ ,\ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(dup)}
\UnaryInfC{$( \ n :: S \ , \ E \ , \ \textsf{dup} \ P \ ) \longrightarrow
  ( \ n :: n :: S \ , \ E \ , \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(dupErr)}
\UnaryInfC{$( \ \varnothing \ , \ E \ , \ \textsf{dup} \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(add)}
\UnaryInfC{$( \ m :: n :: S \ , \ E \ , \ \textsf{add} \ P \ ) \longrightarrow ( \ (m + n) :: S \ , \ E \ , \ P \ )$}
\end{prooftree}

\begin{equation*}
\begin{prooftree}
\AxiomC{}
\RightLabel{(addErr1)}
\UnaryInfC{$( \ n :: S \ , \ E \ , \ \mathsf{add} \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}
\qquad
\begin{prooftree}
\AxiomC{}
\RightLabel{(addErr0)}
\UnaryInfC{$( \ \varnothing \ , \ E \ , \ \mathsf{add} \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}
\end{equation*}

\begin{prooftree}
\AxiomC{}
\RightLabel{(sub)}
\UnaryInfC{$( \ m :: n :: S \ , \ E \ , \ \textsf{sub} \ P \ ) \longrightarrow ( \ (m - n) :: S \ , \ E \ , \ P \ )$}
\end{prooftree}

\begin{equation*}
\begin{prooftree}
\AxiomC{}
\RightLabel{(subErr1)}
\UnaryInfC{$( \ n :: S \ , \ E \ , \ \mathsf{sub} \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}
\qquad
\begin{prooftree}
\AxiomC{}
\RightLabel{(subErr0)}
\UnaryInfC{$( \ \varnothing \ , \ E \ , \ \mathsf{sub} \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}
\end{equation*}

\begin{prooftree}
\AxiomC{}
\RightLabel{(ifFalse)}
\UnaryInfC{$( \ 0 :: S \ , \ E \ , \ \textsf{then} \ Q_1 \ \textsf{else} \ Q_2 \ \textsf{end} \ P \ ) \longrightarrow
( \ S \ , \ E \ , \ Q_2 \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$n \not = 0$}
\RightLabel{(ifTrue)}
\UnaryInfC{$( \ n :: S \ , \ E \ , \ \textsf{then} \ Q_1 \ \textsf{else} \ Q_2 \ \textsf{end} \ P \ ) \longrightarrow
( \ S \ , \ E \ , \ Q_1 \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(ifErr)}
\UnaryInfC{$( \ \varnothing \ , \ E \ , \ \textsf{then} \ Q_1 \ \textsf{else} \ Q_2 \ \textsf{end} \ P \ ) \longrightarrow
\mathsf{ERROR}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\mathsf{fetch}(E, x) \in \mathbb Z$}
\RightLabel{(lookup)}
\UnaryInfC{$( \ S \ , \ E \ , \textsf{lookup} \ x \ P \ ) \longrightarrow
 ( \ \mathsf{fetch}(E, x) :: S \ , \ E \ , \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\mathsf{fetch}(E, x) \not \in \mathbb Z$}
\RightLabel{(lookupErr)}
\UnaryInfC{$( \ S \ , \ E \ , \textsf{lookup} \ x \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(assign)}
\UnaryInfC{$( \ n :: S \ , \ E \ , \ \mathsf{assign} \ x \ P \ ) \longrightarrow
( \ S \ , \ \mathsf{update}(E, x, n) \ , \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(assignErr)}
\UnaryInfC{$( \ \varnothing \ , \ E \ , \ \mathsf{assign} \ x \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}

<hr />
<p>
<i>Example evaluation:</i>
</p>
<pre class="example">
( ∅             , []               , push 14 assign X push 15 assign Y lookup X lookup Y add ) ⟶
( 14 :: ∅       , []               , assign X push 15 assign Y lookup X lookup Y add ) ⟶
( ∅             , [X ↦ 14]         , push 15 assign Y lookup X lookup Y add ) ⟶
( 15 :: ∅       , [X ↦ 14]         , assign Y lookup X lookup Y add ) ⟶
( ∅             , [Y ↦ 15; X ↦ 14] , lookup X lookup Y add ) ⟶
( 14 :: ∅       , [Y ↦ 15; X ↦ 14] , lookup Y add ) ⟶
( 15 :: 14 :: ∅ , [Y ↦ 15; X ↦ 14] , add ) ⟶
( 29 :: ∅       , [Y ↦ 15; X ↦ 14] , ϵ ) ✓
</pre>

<hr />

<p>
The other primary concern when it comes to variables is
<b>scoping</b>. This will come in a later section after discussing
subroutines.
</p>
</div>
<div id="outline-container-org86206b1" class="outline-4">
<h4 id="org86206b1"><span class="section-number-4">5.1.1.</span> Exercises</h4>
<div class="outline-text-4" id="text-5-1-1">
<ol class="org-ol">
<li><p>
There is currently no way to <i>unassign</i> variables in the
environment.  Redefine the function
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">update</span> (<span style="color: #a0522d;">e</span> :<span style="color: #228b22;"> env</span>) (<span style="color: #a0522d;">x</span> :<span style="color: #228b22;"> string</span>) (<span style="color: #a0522d;">v</span> :<span style="color: #228b22;"> value option</span>) :<span style="color: #228b22;"> env </span>=
  <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">TODO</span><span style="color: #b22222;"> *)</span>
</pre>
</div>
<p>
which takes an <i>optional value</i> so that <code>update e x (Some v)</code> will
bind <code>x</code> to <code>v</code> in <code>e</code> and <code>update e x None</code> will <i>remove</i> any
bindings of <code>x</code> in the environment.
</p></li>
<li>Extend the command set and the operational semantics to include a
command <code>unassign X</code> which can be used to remove bindings in the
environment within a program.</li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-org0846b42" class="outline-2">
<h2 id="org0846b42"><span class="section-number-2">6.</span> Subroutines</h2>
<div class="outline-text-2" id="text-6">
<p>
A <b>subroutine</b> is an encapsulated piece of code that can be reused and
executed in different contexts within a program.
</p>

<p>
Implementing subroutines in a programming language requires dealing
with several concerns, including <b>parameter passing</b> and <b>return
values</b>.
</p>
</div>
<div id="outline-container-org187cac7" class="outline-3">
<h3 id="org187cac7"><span class="section-number-3">6.1.</span> Stack-Oriented Language with Subroutines</h3>
<div class="outline-text-3" id="text-6-1">
<p>
For stack-oriented languages, we don't need to deal with parameters or
return values of subroutines; all of these is handled on the stack.
This makes adding subroutines to our stack-oriented languages fairly
simple.
</p>

<p>
In the operational semantics of the following stack-oriented language,
we take a configuration to be a program (\(P\)) together with a stack of
integers (\(S\)) and an environment (\(E\)) of bindings <i>which now
includes bindings to programs</i>, or the special \(\mathsf{ERROR}\)
configuration.
</p>

<hr />
<p>
<i>Grammar for a stack-oriented language with subroutines:</i>
</p>

<pre class="example">
&lt;prog&gt;  ::= { &lt;com&gt; }
&lt;com&gt;   ::= push &lt;num&gt; | dup | add | sub
          | then &lt;prog&gt; else &lt;prog&gt; end
          | lookup &lt;ident&gt; | assign &lt;ident&gt;
          | def &lt;ident&gt; begin &lt;prog&gt; end | call &lt;ident&gt;
&lt;num&gt;   ::= ( 0 | ... | 9 ) { 0 | ... | 9 }
&lt;ident&gt; ::= ( A | ... | Z ) { A | ... | Z }
</pre>

<hr />
<p>
<i>Example program:</i>
</p>
<pre class="example">
def F begin
  dup add
end

push 6 assign X
push 5 call F
lookup X call F
</pre>

<hr />
<p>
<i>Operational Semantics for a stack-oriented language with subroutines
(and dynamic scoping):</i>
</p>

\begin{prooftree}
\AxiomC{}
\RightLabel{(push)}
\UnaryInfC{$(\ S \ , \ E \ , \ \textsf{push n} \ P \ ) \longrightarrow ( \ n :: S \ , \ E \ ,\ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(dup)}
\UnaryInfC{$( \ n :: S \ , \ E \ , \ \textsf{dup} \ P \ ) \longrightarrow
  ( \ n :: n :: S \ , \ E \ , \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(dupErr)}
\UnaryInfC{$( \ \varnothing \ , \ E \ , \ \textsf{dup} \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(add)}
\UnaryInfC{$( \ m :: n :: S \ , \ E \ , \ \textsf{add} \ P \ ) \longrightarrow ( \ (m + n) :: S \ , \ E \ , \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(addErr1)}
\UnaryInfC{$( \ n :: S \ , \ E \ , \ \mathsf{add} \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(addErr0)}
\UnaryInfC{$( \ \varnothing \ , \ E \ , \ \mathsf{add} \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(sub)}
\UnaryInfC{$( \ m :: n :: S \ , \ E \ , \ \textsf{sub} \ P \ ) \longrightarrow ( \ (m - n) :: S \ , \ E \ , \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(subErr1)}
\UnaryInfC{$( \ n :: S \ , \ E \ , \ \mathsf{sub} \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(subErr0)}
\UnaryInfC{$( \ \varnothing \ , \ E \ , \ \mathsf{sub} \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(ifFalse)}
\UnaryInfC{$( \ 0 :: S \ , \ E \ , \ \textsf{then} \ Q_1 \ \textsf{else} \ Q_2 \ \textsf{end} \ P \ ) \longrightarrow
( \ S \ , \ E \ , \ Q_2 \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$n \not = 0$}
\RightLabel{(ifTrue)}
\UnaryInfC{$( \ n :: S \ , \ E \ , \ \textsf{then} \ Q_1 \ \textsf{else} \ Q_2 \ \textsf{end} \ P \ ) \longrightarrow
( \ S \ , \ E \ , \ Q_1 \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(ifErr)}
\UnaryInfC{$( \ \varnothing \ , \ E \ , \ \textsf{then} \ Q_1 \ \textsf{else} \ Q_2 \ \textsf{end} \ P \ ) \longrightarrow
\mathsf{ERROR}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\mathsf{fetch}(E, x) \in \mathbb Z$}
\RightLabel{(lookup)}
\UnaryInfC{$( \ S \ , \ E \ , \textsf{lookup} \ x \ P \ ) \longrightarrow
 ( \ \mathsf{fetch}(E, x) :: S \ , \ E \ , \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\mathsf{fetch}(E, x) \not \in \mathbb Z$}
\RightLabel{(lookupErr)}
\UnaryInfC{$( \ S \ , \ E \ , \textsf{lookup} \ x \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(assign)}
\UnaryInfC{$( \ n :: S \ , \ E \ , \ \mathsf{assign} \ x \ P \ ) \longrightarrow
( \ S \ , \ \mathsf{update}(E, x, n) \ , \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(assignErr)}
\UnaryInfC{$( \ \varnothing \ , \ E \ , \ \mathsf{assign} \ x \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(funDef)}
\UnaryInfC{$( \ S \ , \ E \ , \ \mathsf{def} \ F \ \mathsf{begin} \ Q \ \mathsf{end} \ P \ ) \longrightarrow
( \ S \ , \ \mathsf{update}(E, F, Q) \ , \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\mathsf{fetch}(E, F) = Q$}
\RightLabel{(call)}
\UnaryInfC{$( \ S \ , \ E \ , \ \mathsf{call} \ F \ P \ ) \longrightarrow ( \ S \ , \ E \ , \ Q \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\mathsf{fetch}(E, F) = \bot \quad$ or $\quad \mathsf{fetch}(E, F) \in \mathbb Z$}
\RightLabel{(callErr)}
\UnaryInfC{$( \ S \ , \ E \ , \ \mathsf{call} \ F \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}

<hr />
<p>
<i>Example execution:</i>
</p>

<pre class="example">
( ∅                 , []                   , def F begin dup add end push 6 assign X push 5 call F lookup X call F ) ⟶
( ∅                 , [F ↦ dup add]        , push 6 assign X push 5 call F lookup X call F) ⟶
( 6 :: ∅            , [F ↦ dup add]        , assign X push 5 call F lookup X callF) ⟶
( ∅                 , [X ↦ 6, F ↦ dup add] , push 5 call F lookup X call F ) ⟶
( 5 :: ∅            , [X ↦ 6, F ↦ dup add] , call F lookup X call F ) ⟶
( 5 :: ∅            , [X ↦ 6, F ↦ dup add] , dup add lookup X call F ) ⟶
( 5 :: 5 :: ∅       , [X ↦ 6, F ↦ dup add] , add lookup X call F ) ⟶
( 10 :: ∅           , [X ↦ 6, F ↦ dup add] , lookup X call F ) ⟶
( 6 :: 10 :: ∅      , [X ↦ 6, F ↦ dup add] , call F ) ⟶
( 6 :: 10 :: ∅      , [X ↦ 6, F ↦ dup add] , dup add ) ⟶
( 6 :: 6 :: 10 :: ∅ , [X ↦ 6, F ↦ dup add] , add ) ⟶
( 12 :: 10 :: ∅     , [X ↦ 6, F ↦ dup add] , ϵ ) ✓
</pre>
</div>
<div id="outline-container-org584b49b" class="outline-4">
<h4 id="org584b49b"><span class="section-number-4">6.1.1.</span> Exercises</h4>
<div class="outline-text-4" id="text-6-1-1">
<ol class="org-ol">
<li>Implement the function <code>SWAP</code> in the stack-oriented language with
subroutines which swaps the top two values on the stack, assuming
there are two values on the top of the stack. Also implement the
function <code>ROT</code> which rotates to the top three elements of the
stack, i.e., <code>x :: y :: z :: S</code> becomes <code>z :: x :: y :: S</code>.</li>
<li>Implement <code>MUL</code> which multiplies the top two elements of the
stack.</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org77fe603" class="outline-3">
<h3 id="org77fe603"><span class="section-number-3">6.2.</span> Parameter Passing</h3>
<div class="outline-text-3" id="text-6-2">
<p>
<b>Parameter passing</b> is part of the <b>evaluation strategy</b> of a
programming language.  It refers to how parameters are passed to a
function when it is called.  There are two forms of parameter passing
we primarily considered in the course:
</p>
<ul class="org-ul">
<li><b>call-by-value.</b> When a function is called, its arguments are
evaluated and the function is given the <i>values</i> of its arguments.
The important feature of the call-by-value strategy is that the
arguments of a function are evaluated exactly once.</li>
<li><b>call-by-name.</b> when a function is called, it is given the <i>names</i>
of its arguments, to which a function can refer. The important
feature of the call-by-name strategy is that, arguments are only
evaluated if they are used; if a function never uses an argument,
then that argument is never evaluated.</li>
</ul>

<p>
The details of the call-by-name and call-by-value strategies are more
subtle in the context of imperative languages with mutable variable
bindings.  These strategies are more easily understood in the context
of functional languages, as in the following examples.
</p>

<p>
Note that both of these example use the <b>substitution model</b> for their
operational semantics.
</p>
</div>
<div id="outline-container-orga62d859" class="outline-4">
<h4 id="orga62d859"><span class="section-number-4">6.2.1.</span> A Functional Language with Call-by-Name Parameter Passing</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
<i>Grammar for a simple functional language:</i>
</p>
<pre class="example">
&lt;expr&gt;  ::= &lt;value&gt;
          | &lt;expr&gt; &lt;expr&gt;
          | &lt;expr&gt; (+ | -) &lt;expr&gt;
          | '(' &lt;expr&gt; ')'
&lt;value&gt; ::= &lt;num&gt; | &lt;ident&gt;
          | fun &lt;ident&gt; -&gt; &lt;expr&gt;
&lt;num&gt;   ::= ( 0 | ... | 9 ) { 0 | ... | 9 }
&lt;ident&gt; ::= ( a | ... | z ) { a | ... | z }
</pre>
<hr />
<p>
<i>Example program:</i>
</p>
<pre class="example">
(fun x -&gt; fun y -&gt; x)
  2
  ((fun z -&gt; z + 5) 4)
</pre>
<hr />
<p>
<i>Operational semantics for the lambda calculus with call-by-name parameter passing and left-to-right evaluation:</i>
</p>

\begin{equation*}
\begin{prooftree}
\AxiomC{$e_1 \longrightarrow e_1'$}
\RightLabel{(appRed)}
\UnaryInfC{$e_1 \ e_2 \longrightarrow e_1' \ e_2$}
\end{prooftree}
\qquad
\begin{prooftree}
\AxiomC{}
\RightLabel{(cbnBeta)}
\UnaryInfC{$(\texttt{fun} \ x \ \texttt{->} \ e_1) \ e_2 \longrightarrow e_1[e_2 / x]$}
\end{prooftree}
\end{equation*}

\begin{equation*}
\begin{prooftree}
\AxiomC{$e_1 \longrightarrow e_1'$}
\RightLabel{(addRedLeft)}
\UnaryInfC{$e_1 \ \texttt{+} \ e_2 \longrightarrow e_1' \ \texttt{+} \ e_2$}
\end{prooftree}
\qquad
\begin{prooftree}
\AxiomC{$v \in \mathbb Z$}
\AxiomC{$e_2 \longrightarrow e_2'$}
\RightLabel{(addRedRight)}
\BinaryInfC{$v \ \texttt{+} \ e_2 \longrightarrow v \ \texttt{+} \ e_2'$}
\end{prooftree}
\end{equation*}

\begin{prooftree}
\AxiomC{$m \in \mathbb Z$}
\AxiomC{$n \in \mathbb Z$}
\RightLabel{(addNum)}
\BinaryInfC{$m \ \texttt{+} \ n \longrightarrow m + n$}
\end{prooftree}

\begin{equation*}
\begin{prooftree}
\AxiomC{$e_1 \longrightarrow e_1'$}
\RightLabel{(subRedLeft)}
\UnaryInfC{$e_1 \ \texttt{-} \ e_2 \longrightarrow e_1' \ \texttt{-} \ e_2$}
\end{prooftree}
\qquad
\begin{prooftree}
\AxiomC{$v \in \mathbb Z$}
\AxiomC{$e_2 \longrightarrow e_2'$}
\RightLabel{(subRedRight)}
\BinaryInfC{$v \ \texttt{-} \ e_2 \longrightarrow v \ \texttt{-} \ e_2'$}
\end{prooftree}
\end{equation*}

\begin{prooftree}
\AxiomC{$m \in \mathbb Z$}
\AxiomC{$n \in \mathbb Z$}
\RightLabel{(subNum)}
\BinaryInfC{$m \ \texttt{-} \ n \longrightarrow m - n$}
\end{prooftree}

<hr />
<p>
<i>Example evaluation:</i> Note that the "second" argument is never
evaluated.
</p>

<pre class="example">
(fun x -&gt; fun y -&gt; x) 2  ((fun z -&gt; z + 5) 4) ⟶

(fun y -&gt; x) [2 / x]     ((fun z -&gt; z + 5) 4) ≡

(fun y -&gt; 2)             ((fun z -&gt; z + 5) 4) ⟶

2 [(fun z -&gt; z + 5) 4 / y]                    ≡

2
</pre>
</div>
</div>
<div id="outline-container-org124e042" class="outline-4">
<h4 id="org124e042"><span class="section-number-4">6.2.2.</span> Functional language with Call-by-Value Parameter Passing</h4>
<div class="outline-text-4" id="text-6-2-2">
<p>
<i>Operational semantics for a simple functional language with
call-by-value parameter passing and left-to-right evaluation:</i>
</p>

\begin{equation*}
\begin{prooftree}
\AxiomC{$e_1 \longrightarrow e_1'$}
\RightLabel{(appRedLeft)}
\UnaryInfC{$e_1 \ e_2 \longrightarrow e_1' \ e_2$}
\end{prooftree}
\qquad
\begin{prooftree}
\AxiomC{$e_2 \longrightarrow e_2'$}
\RightLabel{(appRedRight)}
\UnaryInfC{$(\texttt{fun} \ x \ \texttt{->} e_1) \ e_2 \longrightarrow (\texttt{fun} \ x \ \texttt{->} e_1) \ e_2'$}
\end{prooftree}
\end{equation*}

\begin{prooftree}
\AxiomC{$v$ is a value}
\RightLabel{(cbvBeta)}
\UnaryInfC{$(\texttt{fun} \ x \ \texttt{->} \ e) \ v \longrightarrow e[v / x]$}
\end{prooftree}

\begin{equation*}
\begin{prooftree}
\AxiomC{$e_1 \longrightarrow e_1'$}
\RightLabel{(addRedLeft)}
\UnaryInfC{$e_1 \ \texttt{+} \ e_2 \longrightarrow e_1' \ \texttt{+} \ e_2$}
\end{prooftree}
\qquad
\begin{prooftree}
\AxiomC{$v \in \mathbb Z$}
\AxiomC{$e_2 \longrightarrow e_2'$}
\RightLabel{(addRedRight)}
\BinaryInfC{$v \ \texttt{+} \ e_2 \longrightarrow v \ \texttt{+} \ e_2'$}
\end{prooftree}
\end{equation*}
<p>
p
</p>
\begin{prooftree}
\AxiomC{$m \in \mathbb Z$}
\AxiomC{$n \in \mathbb Z$}
\RightLabel{(addNum)}
\BinaryInfC{$m \ \texttt{+} \ n \longrightarrow m + n$}
\end{prooftree}

\begin{equation*}
\begin{prooftree}
\AxiomC{$e_1 \longrightarrow e_1'$}
\RightLabel{(subRedLeft)}
\UnaryInfC{$e_1 \ \texttt{-} \ e_2 \longrightarrow e_1' \ \texttt{-} \ e_2$}
\end{prooftree}
\qquad
\begin{prooftree}
\AxiomC{$v \in \mathbb Z$}
\AxiomC{$e_2 \longrightarrow e_2'$}
\RightLabel{(subRedRight)}
\BinaryInfC{$v \ \texttt{-} \ e_2 \longrightarrow v \ \texttt{-} \ e_2'$}
\end{prooftree}
\end{equation*}

\begin{prooftree}
\AxiomC{$m \in \mathbb Z$}
\AxiomC{$n \in \mathbb Z$}
\RightLabel{(subNum)}
\BinaryInfC{$m \ \texttt{-} \ n \longrightarrow m - n$}
\end{prooftree}

<hr />
<p>
<i>Example evaluation:</i> Note that the "second" argument is evaluated
before it passed to the function (i.e., before the function is applied
to it).
</p>

<pre class="example">
(fun x -&gt; fun y -&gt; x) 2  ((fun z -&gt; z + 5) 4) ⟶

(fun y -&gt; x) [2 / x]     ((fun z -&gt; z + 5) 4) ≡

(fun y -&gt; 2)             ((fun z -&gt; z + 5) 4) ⟶

(fun y -&gt; 2)             ((z + 5) [4 / z])    ≡

(fun y -&gt; 2)             (4 + 5)              ⟶

(fun y -&gt; 2)             9                    ⟶

2 [ 9 / y ]                                   ≡

2
</pre>
</div>
</div>
<div id="outline-container-orgc573295" class="outline-4">
<h4 id="orgc573295"><span class="section-number-4">6.2.3.</span> Exercises</h4>
<div class="outline-text-4" id="text-6-2-3">
<ol class="org-ol">
<li>Give an example of a program which does not terminate using
call-by-value parameter passing, but does terminate using
call-by-name parameter passing.</li>
<li>Give an example of a program which will take ~4 times as many
reductions to terminate using call-by-name parameter passing, as
compared to call-by-value parameter passing.</li>
<li>Write a program that does not terminate using call-by-name
parameter passing.</li>
<li><p>
Determine what the following program evaluates to.
</p>
<pre class="example">
     (fun f -&gt; fun x -&gt; f x x)
       (fun y -&gt; fun z -&gt; fun a -&gt; y (z a))
p       (fun x -&gt; x + 1) 3
</pre></li>
<li><p>
We can represents expressions in the language as an ADT.  Implement
following function
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">expr</span>
  = <span style="color: #000000; background-color: #ffffff;">App</span> <span style="color: #a020f0;">of</span> expr * expr
  | <span style="color: #000000; background-color: #ffffff;">Add</span> <span style="color: #a020f0;">of</span> expr * expr
  | <span style="color: #000000; background-color: #ffffff;">Sub</span> <span style="color: #a020f0;">of</span> expr * expr
  | <span style="color: #000000; background-color: #ffffff;">Num</span> <span style="color: #a020f0;">of</span> int
  | <span style="color: #000000; background-color: #ffffff;">Var</span> <span style="color: #a020f0;">of</span> string
  | <span style="color: #000000; background-color: #ffffff;">Fun</span> <span style="color: #a020f0;">of</span> string * expr

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">is_value</span> (<span style="color: #a0522d;">e</span> :<span style="color: #228b22;"> expr</span>) :<span style="color: #228b22;"> bool </span>=
  <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">TODO</span><span style="color: #b22222;"> *)</span>
</pre>
</div>
<p>
which returns <code>true</code> if <code>e</code> is a value (i.e., it is a number, a
variable, or a function), and <code>false</code> otherwise.
</p></li>
<li><p>
You may notice that our language has no error configuration.  We
say that an expression is <b>stuck</b> if it is not a value but it
cannot be further reduced.  Implement the function
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">is_stuck</span> (<span style="color: #a0522d;">e</span> :<span style="color: #228b22;"> expr</span>) :<span style="color: #228b22;"> bool </span>=
  <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">TODO</span><span style="color: #b22222;"> *)</span>
</pre>
</div>
<p>
which returns <code>true</code> if <code>e</code> is stuck and <code>false</code> otherwise.
</p></li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-org17891d0" class="outline-2">
<h2 id="org17891d0"><span class="section-number-2">7.</span> Dynamic Scoping</h2>
<div class="outline-text-2" id="text-7">
<p>
<b>Dynamic scoping</b> refers to the use of <i>computational (temporal)
context</i> to determine when a binding is available.  In its simplest
form, we may think of all bindings as globally available as soon as
they have been instantiated in the process of executing a program.
</p>

<p>
In a language with dynamic scoping, when it comes to determining what
bindings are available to a subroutine, it doesn't matter where a
subroutine is <i>defined</i>, but rather where it is <i>called</i>.
</p>

<p>
Bash is a widely used language with dynamic scoping, but in general,
dynamic scoping is not common in modern programming languages.  It is,
however, much easier to implement than lexical scoping.
</p>

<p>
The stack-oriented language with subroutines given above implements
dynamic scoping by fiat.
</p>
</div>
<div id="outline-container-org061188c" class="outline-3">
<h3 id="org061188c"><span class="section-number-3">7.1.</span> Examples</h3>
<div class="outline-text-3" id="text-7-1">
<p>
<i>Example bash program highlighting dynamic scoping:</i>
</p>
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #a020f0;">function</span> <span style="color: #0000ff;">f</span> () {
  <span style="color: #a0522d;">X</span>=2
}
<span style="color: #a020f0;">function</span> <span style="color: #0000ff;">g</span> () {
  <span style="color: #483d8b;">echo</span> $<span style="color: #a0522d;">X</span>
}

<span style="color: #a0522d;">X</span>=1
g
f
g

<span style="color: #b22222;"># </span><span style="color: #b22222;">prints:</span>
<span style="color: #b22222;"># </span><span style="color: #b22222;">1</span>
<span style="color: #b22222;"># </span><span style="color: #b22222;">2</span>
</pre>
</div>

<hr />
<p>
<i>Example program in the stack-oriented language highlighting dynamic scoping:</i>
</p>
<pre class="example">
def F begin
  push 2 assign X
end

def G begin
  lookup X
end

push 1 assign X
call G
call F
call G
</pre>

<hr />
<p>
<i>Example evaluation:</i>
</p>
<pre class="example">
( ∅           , []                                         , def F begin push 2 assign x end def G begin lookup X end push 1 assign X call G call F call G) ⟶
( ∅           , [F ↦ push 2 assign X]                      , def G begin lookup X push 1 assign X call G call F call G) ⟶
( ∅           , [G ↦ lookup X; F ↦ push 2 assign X]        , push 1 assign X call G call F call G) ⟶
( 1 :: ∅      , [G ↦ lookup X; F ↦ push 2 assign X]        , assign X call G call F call G) ⟶
( ∅           , [X ↦ 1; G ↦ lookup X; F ↦ push 2 assign X] , call G call F call G) ⟶
( ∅           , [X ↦ 1; G ↦ lookup X; F ↦ push 2 assign X] , lookup X call F call G) ⟶
( 1 :: ∅      , [X ↦ 1; G ↦ lookup X; F ↦ push 2 assign X] , call F call G) ⟶
( 1 :: ∅      , [X ↦ 1; G ↦ lookup X; F ↦ push 2 assign X] , push 2 assign X call G) ⟶
( 2 :: 1 :: ∅ , [X ↦ 1; G ↦ lookup X; F ↦ push 2 assign X] , assign X call G) ⟶
( 1 :: ∅      , [X ↦ 2; G ↦ lookup X; F ↦ push 2 assign X] , call G) ⟶
( 1 :: ∅      , [X ↦ 2; G ↦ lookup X; F ↦ push 2 assign X] , lookup X) ⟶
( 2 :: 1 :: ∅ , [X ↦ 2; G ↦ lookup X; F ↦ push 2 assign X] , ϵ ) ✓
</pre>
</div>
<div id="outline-container-orgb86fdfa" class="outline-4">
<h4 id="orgb86fdfa"><span class="section-number-4">7.1.1.</span> Exercises</h4>
<div class="outline-text-4" id="text-7-1-1">
<ol class="org-ol">
<li><p>
Give an evaluation of the following program.
</p>
<pre class="example">
def F begin
  deg G begin
    lookup X
  end
end

push 1 assign X
call F
call G
</pre></li>
</ol>
</div>
</div>
</div>
</div>
<div id="outline-container-orgce67e97" class="outline-2">
<h2 id="orgce67e97"><span class="section-number-2">8.</span> Lexical Scoping</h2>
<div class="outline-text-2" id="text-8">
<p>
<b>Lexical scoping</b> refers to the use of properties of the source code
 text to deliniate the availability of a binding.  In Python, the body
 of a function, determined by indentation, deliniates <b>function
 scope</b>.  In OCaml, The body of a let-expression is exactly the scope
 of its associated binding (it is not possible to refer to that
 binding outside of the body of the let-expression).  Lexical scoping
 is common among modern programming languages (including both Python and OCaml).
</p>

<p>
In a language with lexical scoping, when it comes to determining what
bindings are available to a subroutine, it doesn't matter where a
subroutine was <i>called</i>, but rather where it was <i>defined</i> (this is
the opposite of dynamic scoping).
</p>

<p>
The implementation lexical scoping depends on a couple
considerations:
</p>
<ul class="org-ul">
<li>Are variables <b>mutable</b>?</li>
<li>Are functions <b>higher-order</b>?</li>
</ul>
</div>

<div id="outline-container-org8677704" class="outline-3">
<h3 id="org8677704"><span class="section-number-3">8.1.</span> Activation Records</h3>
<div class="outline-text-3" id="text-8-1">
<p>
Lexical scoping with <i>mutable</i> variables requires maintaining a <b>call
stack</b>.  The call stack keeps track of the function calls made during
the evaluating a program, along with local variables to function
calls.
</p>

<p>
Each function call (transferring control from the caller to the callee)
creates an <b>activation record</b> (or <b>frame</b>) which keeps track of:
</p>
<ul class="org-ul">
<li>the input parameters of the function</li>
<li>a pointer to the activation record in which the function was defined</li>
<li>a pointer to where to return after completing the function call</li>
</ul>
<p>
Returning from a subroutine (transferring control from the callee to
the caller) removes its associated frame from the stack.
</p>

<p>
At a low level, we can think of an activation record as having the
following rough structure.
</p>
<pre class="example">
TOP OF THE STACK
+--------------+
| localK       |
| ...          |
| local2       |
| local1       |
| return_addr  |
| def_addr     |
| argN         |
| ...          |
| arg2         |
| arg1         |
+--------------+
↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
</pre>

<p>
Conceptually, we represent the call stack within the environment.
That is, rather than maintaining a collection of bindings in the
environment, we maintain a stack of activation records.  In OCaml, we
might implement this as follows.<sup><a id="fnr.9" class="footref" href="#fn.9" role="doc-backlink">9</a></sup> Note that this implementation has our stack-oriented
languages in mind so there are no parameters in a record.
</p>

<p>
<b>IMPORTANT.</b> This works slightly differently than in project 2. Note
 that the <code>fetch</code> operation returns the identifier of the record in
 which it found a binding.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">command</span> = unit <span style="color: #b22222;">(* </span><span style="color: #b22222;">DUMMY TYPE</span><span style="color: #b22222;"> *)</span>
<span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">program</span> = command list
<span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">value</span>
  = <span style="color: #000000; background-color: #ffffff;">Num</span> <span style="color: #a020f0;">of</span> int
  | <span style="color: #000000; background-color: #ffffff;">Prog</span> <span style="color: #a020f0;">of</span> program
<span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">record</span> =
  { id : int
  ; locals : (string * value) list
  ; ret_prog : program
  ; def_pointer : int
  }

<span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">env</span> = record list

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a0522d;">empty_env</span> =
  [ { id = 0
    ; locals = <span style="color: #000000; background-color: #ffffff;">[]</span>
    ; def_pointer = -1
    ; ret_prog = <span style="color: #000000; background-color: #ffffff;">[]</span>
    }
  ]

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">fetch</span> (<span style="color: #a0522d;">e</span> :<span style="color: #228b22;"> env</span>) (<span style="color: #a0522d;">x</span> :<span style="color: #228b22;"> string</span>) :<span style="color: #228b22;"> (value * int) option </span>=
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #0000ff;">go</span> <span style="color: #a0522d;">e</span> <span style="color: #a0522d;">x</span> <span style="color: #a0522d;">i</span> =
    <span style="color: #a020f0;">match</span> e <span style="color: #a020f0;">with</span>
    | r <span style="color: #000000; background-color: #ffffff;">::</span> e -&gt;
      <span style="color: #a020f0;">if</span> r.id = i
      <span style="color: #a020f0;">then</span>
        <span style="color: #a020f0;">match</span> <span style="color: #228b22;">List.</span>assoc_opt x r.locals <span style="color: #a020f0;">with</span>
        | <span style="color: #000000; background-color: #ffffff;">Some</span> v -&gt; <span style="color: #000000; background-color: #ffffff;">Some</span> (v, i)
        | <span style="color: #000000; background-color: #ffffff;">None</span> -&gt; go e x r.def_pointer
      <span style="color: #a020f0;">else</span> go e x i
    | _ -&gt; <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">impossible</span><span style="color: #b22222;"> *)</span>
  <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #a020f0;">match</span> e <span style="color: #a020f0;">with</span>
  | r <span style="color: #000000; background-color: #ffffff;">::</span> _ -&gt; go e x r.id
  | _ -&gt; <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">impossible</span><span style="color: #b22222;"> *)</span>

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">update</span> (<span style="color: #a0522d;">e</span> :<span style="color: #228b22;"> env</span>) (<span style="color: #a0522d;">x</span> :<span style="color: #228b22;"> string</span>) (<span style="color: #a0522d;">v</span> :<span style="color: #228b22;"> value</span>) :<span style="color: #228b22;"> env </span>=
  <span style="color: #a020f0;">match</span> e <span style="color: #a020f0;">with</span>
  | r <span style="color: #000000; background-color: #ffffff;">::</span> e -&gt; { r <span style="color: #a020f0;">with</span> locals = (x, v) <span style="color: #000000; background-color: #ffffff;">::</span> r.locals } <span style="color: #000000; background-color: #ffffff;">::</span> e
  | <span style="color: #000000; background-color: #ffffff;">[]</span> -&gt; <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">impossible</span><span style="color: #b22222;"> *)</span>
</pre>
</div>
</div>

<div id="outline-container-orge063af1" class="outline-4">
<h4 id="orge063af1"><span class="section-number-4">8.1.1.</span> Stack-Oriented Language with Mutable Variables and Lexical Scoping</h4>
<div class="outline-text-4" id="text-8-1-1">
<p>
Lexical scoping becomes more subtle to implement if functions are
higher-order.  In this example, we do not allow higher-order
functions, but we do allow nested function definitions.
</p>

<p>
In the operational semantics for the following stack-oriented
language, we take a configuration to be a program (\(P\)) together with
a stack of integers (\(S\)) and an <i>call stack</i> (\(E\)) which is a stack
of records as describe above. We use
</p>

\begin{equation*}
\langle i , L, R, j \rangle
\end{equation*}

<p>
to denote an activation record with identifier \(i\), local bindings
\(L\), return program \(R\), and pointer \(j\) to the defining activation
record.
</p>

<p>
This is very similar to what was done in project 2.
</p>

<hr />
<p>
<i>Operational Semantics for a stack-oriented language with lexical scoping and
mutable variables:</i>
</p>


\begin{prooftree}
\AxiomC{}
\RightLabel{(push)}
\UnaryInfC{$(\ S \ , \ E \ , \ \textsf{push n} \ P \ ) \longrightarrow ( \ n :: S \ , \ E \ ,\ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(dup)}
\UnaryInfC{$( \ n :: S \ , \ E \ , \ \textsf{dup} \ P \ ) \longrightarrow
  ( \ n :: n :: S \ , \ E \ , \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(dupErr)}
\UnaryInfC{$( \ \varnothing \ , \ E \ , \ \textsf{dup} \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(add)}
\UnaryInfC{$( \ m :: n :: S \ , \ E \ , \ \textsf{add} \ P \ ) \longrightarrow ( \ (m + n) :: S \ , \ E \ , \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(addErr1)}
\UnaryInfC{$( \ n :: S \ , \ E \ , \ \mathsf{add} \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(addErr0)}
\UnaryInfC{$( \ \varnothing \ , \ E \ , \ \mathsf{add} \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(sub)}
\UnaryInfC{$( \ m :: n :: S \ , \ E \ , \ \textsf{sub} \ P \ ) \longrightarrow ( \ (m - n) :: S \ , \ E \ , \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(subErr1)}
\UnaryInfC{$( \ n :: S \ , \ E \ , \ \mathsf{sub} \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(subErr0)}
\UnaryInfC{$( \ \varnothing \ , \ E \ , \ \mathsf{sub} \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(ifFalse)}
\UnaryInfC{$( \ 0 :: S \ , \ E \ , \ \textsf{then} \ Q_1 \ \textsf{else} \ Q_2 \ \textsf{end} \ P \ ) \longrightarrow
( \ S \ , \ E \ , \ Q_2 \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$n \not = 0$}
\RightLabel{(ifTrue)}
\UnaryInfC{$( \ n :: S \ , \ E \ , \ \textsf{then} \ Q_1 \ \textsf{else} \ Q_2 \ \textsf{end} \ P \ ) \longrightarrow
( \ S \ , \ E \ , \ Q_1 \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(ifErr)}
\UnaryInfC{$( \ \varnothing \ , \ E \ , \ \textsf{then} \ Q_1 \ \textsf{else} \ Q_2 \ \textsf{end} \ P \ ) \longrightarrow
\mathsf{ERROR}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\mathsf{fetch}(E, x)$ is a number}
\RightLabel{(lookup)}
\UnaryInfC{$( \ S \ , \ E \ , \textsf{lookup} \ x \ P \ ) \longrightarrow
 ( \ \mathsf{fetch}(E, x) :: S \ , \ E \ , \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\mathsf{fetch}(E, x)$ is not a number}
\RightLabel{(lookupErr)}
\UnaryInfC{$( \ S \ , \ E \ , \textsf{lookup} \ x \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(assign)}
\UnaryInfC{$( \ m :: S \ , \ E \ , \ \mathsf{assign} \ x \ P \ ) \longrightarrow
( \ S \ , \ \mathsf{update}(E, x, m) \ , \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(assignErr)}
\UnaryInfC{$( \ \varnothing \ , \ E \ , \ \mathsf{assign} \ x \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(funDef)}
\UnaryInfC{$( \ S \ , \ E \ , \ \mathsf{def} \ F \ \mathsf{begin} \ Q \ \mathsf{end} \ P \ ) \longrightarrow
( \ S \ , \ \mathsf{update}(E, F, Q) \ , \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\mathsf{fetch}(E, F) = (Q, i)$ and $Q$ is a program}
\RightLabel{(call)}
\UnaryInfC{$( \ S \ , E \ , \ \mathsf{call} \ F \ P \ ) \longrightarrow ( \ S \ , \ \langle \mathsf{len}(E), \varnothing, P, i \rangle :: E \ , \ Q \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(return)}
\UnaryInfC{$( \ S \ , \ \langle i, L, R, j \rangle :: E \ , \ \epsilon \ ) \longrightarrow ( \ S \ , \ E \ , \ R \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\mathsf{fetch}(E, F)$ is not a program}
\RightLabel{(callErr)}
\UnaryInfC{$( \ S \ , \ E \ , \ \mathsf{call} \ F \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}

<hr />
<p>
<i>Example program:</i>
</p>

<pre class="example">
push 2 assign X

def F begin
  lookup X
  push 4 assign X
end

call F
push 3 assign X
call F
</pre>

<hr />
<p>
<i>Example evaluation:</i>
</p>
<pre class="example">
( ∅
, ⟨0 , [] , ϵ , -1 ⟩ ::
  ∅
, push 2 assign X def F begin lookup X push 4 assign X end call F push 3 assign X call F
) ⟶

( 2 :: ∅
, ⟨0 , [] , ϵ , -1 ⟩ ::
  ∅
, assign X def F begin lookup X push 4 assign X end call F push 3 assign X call F
) ⟶

( ∅
, ⟨ 0 , [X ↦ 2] , ϵ , -1 ⟩ ::
  ∅
, def F begin lookup X push 4 assign X end call F push 3 assign X call F
) ⟶

( ∅
, ⟨ 0 , [F ↦ lookup X push 4 assign X; X ↦ 2] , ϵ , -1 ⟩ ::
  ∅
, call F push 3 assign X call F
) ⟶

( ∅
, ⟨ 1 , [] , push 3 assign X call F , 0 ⟩ ::
  ⟨ 0 , [F ↦ lookup X push 4 assign X; X ↦ 2] , ϵ , -1 ⟩ ::
  ∅
, lookup X push 4 assign X
) ⟶

( 2 :: ∅
, ⟨ 1 , [] , push 3 assign X call F , 0 ⟩ ::
  ⟨ 0 , [F ↦ lookup X push 4 assign X; X ↦ 2] , ϵ , -1 ⟩ ::
  ∅
, push 4 assign X
) ⟶

( 4 :: 2 :: ∅
, ⟨ 1 , [] , push 3 assign X call F , 0 ⟩ ::
  ⟨ 0 , [F ↦ lookup X push 4 assign X; X ↦ 2] , ϵ , -1 ⟩ ::
  ∅
, assign X
) ⟶

( 2 :: ∅
, ⟨ 1 , [X ↦ 4] , push 3 assign X call F , 0 ⟩ ::
  ⟨ 0 , [F ↦ lookup X push 4 assign X; X ↦ 2] , ϵ , -1 ⟩ ::
  ∅
, ϵ
) ⟶

( 2 :: ∅
, ⟨ 0 , [F ↦ lookup X push 4 assign X; X ↦ 2] , ϵ , -1 ⟩ ::
  ∅
, push 3 assign X call F
) ⟶

( 3 :: 2 :: ∅
, ⟨ 0 , [F ↦ lookup X push 4 assign X; X ↦ 2] , ϵ , -1 ⟩ ::
  ∅
, assign X call F
) ⟶

( 2 :: ∅
, ⟨ 0 , [F ↦ lookup X push 4 assign X; X ↦ 3] , ϵ , -1 ⟩ ::
  ∅
, call F
) ⟶

( 2 :: ∅
, ⟨ 1 , [] , ϵ , 0 ⟩ ::
  ⟨ 0 , [F ↦ lookup X push 4 assign X; X ↦ 3] , ϵ , -1 ⟩ ::
  ∅
, lookup X push 4 assign X
) ⟶

( 3 :: 2 :: ∅
, ⟨ 1 , [] , ϵ , 0 ⟩ ::
  ⟨ 0 , [F ↦ lookup X push 4 assign X; X ↦ 3] , ϵ , -1 ⟩ ::
  ∅
, push 4 assign X
) ⟶

( 4 :: 3 :: 2 :: ∅
, ⟨ 1 , [] , ϵ , 0 ⟩ ::
  ⟨ 0 , [F ↦ lookup X push 4 assign X; X ↦ 3] , ϵ , -1 ⟩ ::
  ∅
, assign X
) ⟶

( 3 :: 2 :: ∅
, ⟨ 1 , [X ↦ 4] , ϵ , 0 ⟩ ::
  ⟨ 0 , [F ↦ lookup X push 4 assign X; X ↦ 3] , ϵ , -1 ⟩ ::
  ∅
, ϵ
) ⟶

( 3 :: 2 :: ∅
, ⟨ 0 , [F ↦ lookup X push 4 assign X; X ↦ 3] , ϵ , -1 ⟩ ::
  ∅
, ϵ
) ⟶

( 3 :: 2 :: ∅
, ∅
, ϵ
) ✓
</pre>
</div>
</div>
<div id="outline-container-orgca172c3" class="outline-4">
<h4 id="orgca172c3"><span class="section-number-4">8.1.2.</span> Exercises</h4>
<div class="outline-text-4" id="text-8-1-2">
<ol class="org-ol">
<li><p>
Give an evaluation of the following program.
</p>
<pre class="example">
push 2 assign X
def F begin
  push 3 assign X
  call G
end
def G begin
  lookup X
end
call F
</pre></li>
<li><p>
Implement the function
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">global_update</span> (<span style="color: #a0522d;">e</span> :<span style="color: #228b22;"> env</span>) (<span style="color: #a0522d;">x</span> :<span style="color: #228b22;"> string</span>) (<span style="color: #a0522d;">v</span> :<span style="color: #228b22;"> value</span>) =
  <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">TODO</span><span style="color: #b22222;"> *)</span>
</pre>
</div>
<p>
which always updates the binding in the <i>global frame</i> (as opposed
to the topmost frame).
</p></li>
<li>Extend the language and the operational semantics to include a
commands <code>gassign</code> which assigns variables in the global frame,
even within a subroutine.</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-org78760df" class="outline-3">
<h3 id="org78760df"><span class="section-number-3">8.2.</span> Closures</h3>
<div class="outline-text-3" id="text-8-2">
<p>
<b>Closures</b> are subroutines together with data they need to be executed
correctly.  At a minimum, this data consists of a collection of
<b>captured bindings</b>, i.e., bindings which may no longer be in scope or
may be shadowed when the function is called.  It often also includes
the name given to the subroutine, as this is important for
implementing recursive functions.
</p>

<p>
Closures can be used to implement higher-order functions and lexically
scoped immutable variable bindings.  If variable bindings are
immutable, a subroutine can be defined as a closure which stores all
the variable bindings it that exist when it is defined.
</p>

<p>
Closure are also used in <b>continuation-passing style</b> implementations
of subroutines.  We can save a closure containing the current
environment and (a pointer to) the return program.  This closure is
often called the <b>current continuation</b>.
</p>

<p>
To simplify things, we can keep track of <i>two</i> stacks, one for data
and the other for holding continuations for returning from a
function.<sup><a id="fnr.10" class="footref" href="#fn.10" role="doc-backlink">10</a></sup>
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">closure</span> =
  { name: string
  ; captured: (string * value) list
  ; body : program
  }

<span style="color: #000000; font-weight: bold;">and</span> <span style="color: #0000ff;">value</span>
  = <span style="color: #000000; background-color: #ffffff;">Closure</span> <span style="color: #a020f0;">of</span> closure
  | <span style="color: #000000; background-color: #ffffff;">Num</span> <span style="color: #a020f0;">of</span> int

<span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">env</span> = (string * value) list
<span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">ccs</span> = closure list
</pre>
</div>
</div>

<div id="outline-container-org3526885" class="outline-4">
<h4 id="org3526885"><span class="section-number-4">8.2.1.</span> Stack-Oriented Language with Lexical Scoping and Higher-Order Functions</h4>
<div class="outline-text-4" id="text-8-2-1">
<p>
In the operational semantics of the following stack oriented language,
we take a configuration to be a program (\(P\)) together with a stack of
values (\(S\)) <i>which includes integers and closures</i>, a stack
continuations (\(C\)) used for returning from a function call, and an
environment (\(E\)), represented as a list of bindings (as in the case
of our stack-oriented language with dynamic scoping).  We use
</p>

\begin{equation*}
\langle F, L, P \rangle
\end{equation*}

<p>
to denote a closure with name \(F\), captured bindings \(L\), and body
\(P\).
</p>

<p>
Note that we need to be able to put closures on the stack in order to
implement higher-order functions.
</p>

<hr />
<p>
<i>Operational Semantics of a stack-oriented language with lexical
scoping, immutable variables, and higher-order functions:</i>
</p>


\begin{prooftree}
\AxiomC{}
\RightLabel{(push)}
\UnaryInfC{$(\ S \ , \ C \ , \ E \ , \ \textsf{push n} \ P \ ) \longrightarrow ( \ n :: S \ , \ C \ , \ E \ ,\ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(dup)}
\UnaryInfC{$( \ n :: S \ , \ C \ , \ E \ , \ \textsf{dup} \ P \ ) \longrightarrow
  ( \ n :: n :: S \ , \ C \ , \ E \ , \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(dupErr)}
\UnaryInfC{$( \ \varnothing \ , \ C \ , \ E \ , \ \textsf{dup} \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(add)}
\UnaryInfC{$( \ m :: n :: S \ , \ C \ , \ E \ , \ \textsf{add} \ P \ ) \longrightarrow ( \ (m + n) :: S \ , \ C \ , \ E \ , \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(addErr1)}
\UnaryInfC{$( \ n :: S \ , \ C \ , \ E \ , \ \mathsf{add} \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(addErr0)}
\UnaryInfC{$( \ \varnothing \ , \ C \ , \ E \ , \ \mathsf{add} \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(sub)}
\UnaryInfC{$( \ m :: n :: S \ , \ C \ , \ E \ , \ \textsf{sub} \ P \ ) \longrightarrow ( \ (m - n) :: S \ , \ C \ , \ E \ , \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(subErr1)}
\UnaryInfC{$( \ n :: S \ , \ C \ , \ E \ , \ \mathsf{sub} \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(subErr0)}
\UnaryInfC{$( \ \varnothing \ , \ C \ , \ E \ , \ \mathsf{sub} \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(ifFalse)}
\UnaryInfC{$( \ 0 :: S \ , \ C \ , \ E \ , \ \textsf{then} \ Q_1 \ \textsf{else} \ Q_2 \ \textsf{end} \ P \ ) \longrightarrow
( \ S \ , \ C \ , \ E \ , \ Q_2 \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$n \not = 0$}
\RightLabel{(ifTrue)}
\UnaryInfC{$( \ n :: S \ , \ C \ , \ E \ , \ \textsf{then} \ Q_1 \ \textsf{else} \ Q_2 \ \textsf{end} \ P \ ) \longrightarrow
( \ S \ , \ C \ , \ E \ , \ Q_1 \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(ifErr)}
\UnaryInfC{$( \ \varnothing \ , \ E \ , \ \textsf{then} \ Q_1 \ \textsf{else} \ Q_2 \ \textsf{end} \ P \ ) \longrightarrow
\mathsf{ERROR}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\mathsf{fetch}(E, x) \not = \bot$}
\RightLabel{(lookup)}
\UnaryInfC{$( \ S \ , \ C \ , \ E \ , \textsf{lookup} \ x \ P \ ) \longrightarrow
 ( \ \mathsf{fetch}(E, x) :: S \ , \ C \ , \ E \ , \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\mathsf{fetch}(E, x) = \bot$}
\RightLabel{(lookupErr)}
\UnaryInfC{$( \ S \ , \ C \ , \ E \ , \textsf{lookup} \ x \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(assign)}
\UnaryInfC{$( \ n :: S \ , \ C \ , \ E \ , \ \mathsf{assign} \ x \ P \ ) \longrightarrow
( \ S \ , \ C \ , \ \mathsf{update}(E, x, n) \ , \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(assignErr)}
\UnaryInfC{$( \ \varnothing \ , \ E \ , \ \mathsf{assign} \ x \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(funDef)}
\UnaryInfC{$( \ S \ , \ C \ , \ E \ , \ \mathsf{def} \ F \ \mathsf{begin} \ Q \ \mathsf{end} \ P \ ) \longrightarrow
( \ S \ , \ C \ , \ \mathsf{update}(E, F, \langle F, E, Q\rangle) \ , \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\mathsf{fetch}(E, F) = \langle G, L, Q\rangle$}
\RightLabel{(call)}
\UnaryInfC{$( \ S \ , \ C \ , \ E \ , \ \mathsf{call} \ F \ P \ ) \longrightarrow ( \ S \ , \ \langle\mathsf{cc}, E, P\rangle :: C \ , \ \mathsf{update}(L, G, Q) \ , \ Q \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\RightLabel{(return)}
\UnaryInfC{$( \ S \ , \ \langle\mathsf{cc}, E, P \rangle :: C \ , \ L \ , \ \epsilon \ ) \longrightarrow ( \ S \ , \ C \ , \ E \ , \ P \ )$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\mathsf{fetch}(E, F) = \bot \quad$ or $\quad \mathsf{fetch}(E, F) \in \mathbb Z$}
\RightLabel{(callErr)}
\UnaryInfC{$( \ S \ , \ C \ , \ E \ , \ \mathsf{call} \ F \ P \ ) \longrightarrow \mathsf{ERROR}$}
\end{prooftree}

<hr />
<p>
<i>Example evaluation (of the same program as in the previous section:</i>
</p>
<pre class="example">
( ∅
, ∅
, []
, push 2 assign X def F begin lookup X push 4 assign X end call F push 3 assign X call F
) ⟶

( 2 :: ∅
, ∅
, []
, assign X def F begin lookup X push 4 assign X end call F push 3 assign X call F
) ⟶

( ∅
, ∅
, [ X ↦ 2 ]
, def F begin lookup X push 4 assign X end call F push 3 assign X call F
) ⟶

( ∅
, ∅
, [ F ↦ ⟨ F , lookup X push 4 assign X , [X ↦ 2] ⟩
  ; X ↦ 2
  ]
, call F push 3 assign X call F
) ⟶

( ∅
, ⟨ cc , push 3 assign X call F , [ F ↦ ⟨ F , lookup X push 4 assign X , [X ↦ 2] ⟩ ::
  ∅
, [ F ↦ ⟨ F , lookup X push 4 assign X , [X ↦ 2] ⟩
  ; X ↦ 2
  ]
, lookup X push 4 assign X
) ⟶

( 2 :: ∅
, ⟨ cc , push 3 assign X call F , [ F ↦ ⟨ F , lookup X push 4 assign X , [X ↦ 2] ⟩ ; X ↦ 2 ] ⟩ ::
  ∅
, [ F ↦ ⟨ F , lookup X push 4 assign X , [X ↦ 2] ⟩
  ; X ↦ 2
  ]
, push 4 assign X
) ⟶

( 4 :: 2 :: ∅
, ⟨ cc , push 3 assign X call F , [ F ↦ ⟨ F , lookup X push 4 assign X , [X ↦ 2] ⟩ ; X ↦ 2 ] ⟩ ::
  ∅
, [ F ↦ ⟨ F , lookup X push 4 assign X , [X ↦ 2] ⟩
  ; X ↦ 2
  ]
, assign X
) ⟶

( 2 :: ∅
, ⟨ cc , push 3 assign X call F , [ F ↦ ⟨ F , lookup X push 4 assign X , [X ↦ 2] ⟩ ; X ↦ 2 ] ⟩ ::
  ∅
, [ F ↦ ⟨ F , lookup X push 4 assign X , [X ↦ 2] ⟩
  ; X ↦ 4
  ]
, ϵ
) ⟶

( 2 :: ∅
,  ∅
, [ F ↦ ⟨ F , lookup X push 4 assign X , [X ↦ 2] ⟩
  ; X ↦ 2
  ]
, push 3 assign X call F
) ⟶

( 3 :: 2 :: ∅
,  ∅
, [ F ↦ ⟨ F , lookup X push 4 assign X , [X ↦ 2] ⟩
  ; X ↦ 2
  ]
, assign X call F
) ⟶

( 2 :: ∅
,  ∅
, [ F ↦ ⟨ F , lookup X push 4 assign X , [X ↦ 2] ⟩
  ; X ↦ 3
  ]
, call F
) ⟶

( 2 :: ∅
, ⟨ cc , ϵ , [ F ↦ ⟨ F , lookup X push 4 assign X , [X ↦ 2] ⟩ ; X ↦ 3 ] ⟩ ::
  ∅
, [ F ↦ ⟨ F , lookup X push 4 assign X , [X ↦ 2] ⟩
  ; X ↦ 2
  ]
, lookup X push 4 assign X
) ⟶

( 2 :: 2 :: ∅
, ⟨ cc , ϵ , [ F ↦ ⟨ F , lookup X push 4 assign X , [X ↦ 2] ⟩ ; X ↦ 3 ] ⟩ ::
  ∅
, [ F ↦ ⟨ F , lookup X push 4 assign X , [X ↦ 2] ⟩
  ; X ↦ 2
  ]
, push 4 assign X
) ⟶

( 4 :: 2 :: 2 :: ∅
, ⟨ cc , ϵ , [ F ↦ ⟨ F , lookup X push 4 assign X , [X ↦ 2] ⟩ ; X ↦ 3 ] ⟩ ::
  ∅
, [ F ↦ ⟨ F , lookup X push 4 assign X , [X ↦ 2] ⟩
  ; X ↦ 2
  ]
, assign X
) ⟶

( 2 :: 2 :: ∅
, ⟨ cc , ϵ , [ F ↦ ⟨ F , lookup X push 4 assign X , [X ↦ 2] ⟩ ; X ↦ 3 ] ⟩ ::
  ∅
, [ F ↦ ⟨ F , lookup X push 4 assign X , [X ↦ 2] ⟩
  ; X ↦ 4
  ]
, ϵ
) ⟶

( 2 :: 2 :: ∅
,  ∅
, [ F ↦ ⟨ F , lookup X push 4 assign X , [X ↦ 2] ⟩
  ; X ↦ 3
  ]
, ϵ
) ✓
</pre>
<hr />
<p>
<i>Example program with higher-order functions:</i>
</p>
<pre class="example">
def K begin
  assign X
  def F begin
    assign Y
    lookup X
  end
  lookup F
end

push 3 call K assign THREE
push 2 call THREE
</pre>

<hr />
<p>
<i>Example evaluation with higher-order functions:</i>
</p>
<pre class="example">
( ∅
, ∅
, []
, def K begin assign X def F begin assign Y lookup X end lookup F end push 3 call K assign THREE push 2 call THREE
) ⟶

( ∅
, ∅
, [ K ↦ ⟨ K , assign X def F begin assign Y lookup X end lookup F , [] ⟩ ]
, push 3 call K assign THREE push 2 call THREE
) ⟶

( 3 :: ∅
, ∅
, [ K ↦ ⟨ K , assign X def F begin assign Y lookup X end lookup F , [] ⟩ ]
, call K assign THREE push 2 call THREE
) ⟶

( 3 :: ∅
, ⟨ cc , assign THREE push 2 call THREE , [ K ↦ ⟨ K , assign X def F begin assign Y lookup X end lookup F , [] ⟩ ] ⟩ ::
  ∅
, [ K ↦ ⟨ K , assign X def F begin assign Y lookup X end lookup F , [] ⟩ ]
, assign X def F begin assign Y lookup X end lookup F
) ⟶

( ∅
, ⟨ cc , assign THREE push 2 call THREE , [ K ↦ ⟨ K , assign X def F begin assign Y lookup X end lookup F , [] ⟩ ] ⟩ ::
  ∅
, [ X ↦ 3
  ; K ↦ ⟨ K , assign X def F begin assign Y lookup X end lookup F , [] ⟩
  ]
, def F begin assign Y lookup X end lookup F
) ⟶

( ∅
, ⟨ cc , assign THREE push 2 call THREE , [ K ↦ ⟨ K , assign X def F begin assign Y lookup X end lookup F , [] ⟩ ] ⟩ ::
  ∅
, [ F ↦ ⟨ F , assign Y lookup X , [X ↦ 3] ⟩
  ; X ↦ 3
  ; K ↦ ⟨ K , assign X def F begin assign Y lookup X end lookup F , [] ⟩
  ]
, lookup F
) ⟶

( ⟨ F , assign Y lookup X , [X ↦ 3] ⟩ :: ∅
, ⟨ cc , assign THREE push 2 call THREE , [ K ↦ ⟨ K , assign X def F begin assign Y lookup X end lookup F , [] ⟩ ] ⟩ ::
  ∅
, [ F ↦ ⟨ F , assign Y lookup X , [X ↦ 3] ⟩
  ; X ↦ 3
  ; K ↦ ⟨ K , assign X def F begin assign Y lookup X end lookup F , [] ⟩
  ]
, ϵ
) ⟶

( ⟨ F , assign Y lookup X , [X ↦ 3] ⟩ :: ∅
,  ∅
, [ K ↦ ⟨ K , assign X def F begin assign Y lookup X end lookup F , [] ⟩ ]
, assign THREE push 2 call THREE
) ⟶

( ∅
, ∅
, [ THREE ↦ ⟨ F , assign Y lookup X , [X ↦ 3] ⟩
  ; K ↦ ⟨ K , assign X def F begin assign Y lookup X end lookup F , [] ⟩
  ]
, push 2 call THREE
) ⟶

( 2 :: ∅
, ∅
, [ THREE ↦ ⟨ F , assign Y lookup X , [X ↦ 3] ⟩
  ; K ↦ ⟨ K , assign X def F begin assign Y lookup X end lookup F , [] ⟩
  ]
, call THREE
) ⟶

( 2 :: ∅
, ⟨ cc , ϵ , [THREE ↦ ⟨ F , assign Y lookup X , [X ↦ 3] ⟩; K ↦ ⟨ K , assign X def F begin assign Y lookup X end lookup F , [] ⟩] ⟩ ::
  ∅
, [ THREE ↦ ⟨ F , assign Y lookup X , [X ↦ 3] ⟩
  ; X ↦ 3
  ]
, assign Y lookup X
) ⟶

( ∅
, ⟨ cc , ϵ , [THREE ↦ ⟨ F , assign Y lookup X , [X ↦ 3] ⟩; K ↦ ⟨ K , assign X def F begin assign Y lookup X end lookup F , [] ⟩] ⟩ ::
  ∅
, [ Y ↦ 2
  ; THREE ↦ ⟨ F , assign Y lookup X , [X ↦ 3] ⟩
  ; X ↦ 3
  ]
, lookup X
) ⟶

( 3 :: ∅
, ⟨ cc , ϵ , [THREE ↦ ⟨ F , assign Y lookup X , [X ↦ 3] ⟩; K ↦ ⟨ K , assign X def F begin assign Y lookup X end lookup F , [] ⟩] ⟩ ::
  ∅
, [ Y ↦ 2
  ; THREE ↦ ⟨ F , assign Y lookup X , [X ↦ 3] ⟩
  ; X ↦ 3
  ]
, ϵ
) ⟶

( 3 :: ∅
,  ∅
, [ THREE ↦ ⟨ F , assign Y lookup X , [X ↦ 3] ⟩
  ; K ↦ ⟨ K , assign X def F begin assign Y lookup X end lookup F , [] ⟩
  ]
, ϵ
) ✓

</pre>
</div>
</div>


<div id="outline-container-org0eea23e" class="outline-4">
<h4 id="org0eea23e"><span class="section-number-4">8.2.2.</span> Exercises</h4>
<div class="outline-text-4" id="text-8-2-2">
<ol class="org-ol">
<li><p>
Evaluate the following program.
</p>
<pre class="example">
def ADDFIVE begin
  push 5 add
end

def TWICE begin
  assign F
  call F
  call F
end

push 0
lookup ADDFIVE
call TWICE
</pre></li>
<li><p>
Write a program which terminates for the stack-oriented languages
with
</p>

<ul class="org-ul">
<li>dynamic scoping</li>
<li>lexical scoping via activation records</li>
<li>lexical scoping via closures</li>
</ul>

<p>
and leaves one number on the stack, but which leaves a different
number in each of the three cases.
</p></li>
<li>Redefine the language and semantics to include a <code>return</code> command
(as in project 3).</li>
<li>Redefine the language and semantics to include a <code>call</code> command (as
in project 3) so that the language has anonymous functions.</li>
<li><i>(Open ended)</i> Describe the benefit of having two stacks (one for data and one for
returns) instead of just one.</li>
</ol>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">This is, of course, not the only way to achieve
this. We can also use continuation-passing style, as we saw briefly in
lecture.</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">You are not required to write formal typing derivations,
but you should be able to use your intuitions about OCaml to determine
the type of an expression based on its structure (as the OCaml
type-checker does mechanically).</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">In formal language theory, a grammar is a more general than this.</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">The exclamation points are for emphasis, they are not a
part of the derivation.</p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5" role="doc-backlink">5</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">Other source may include more constructs in
EBNF meta-syntax. See, for example, <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">the Wikipedia page</a>.</p></div></div>

<div class="footdef"><sup><a id="fn.6" class="footnum" href="#fnr.6" role="doc-backlink">6</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">It is a theorem of formal language theory that regular grammars and
regular expressions are equivalent in expressivity.</p></div></div>

<div class="footdef"><sup><a id="fn.7" class="footnum" href="#fnr.7" role="doc-backlink">7</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">There is an efficient parsing
algorithm for grammars in Chomsky normal form. This is the main
primary we consider grammars of this form.</p></div></div>

<div class="footdef"><sup><a id="fn.8" class="footnum" href="#fnr.8" role="doc-backlink">8</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">In the remainder of this document, we will continue
this trend. Each following stack-oriented language is a <i>variation on
a theme</i>.</p></div></div>

<div class="footdef"><sup><a id="fn.9" class="footnum" href="#fnr.9" role="doc-backlink">9</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">This is not the most efficient
implementation.</p></div></div>

<div class="footdef"><sup><a id="fn.10" class="footnum" href="#fnr.10" role="doc-backlink">10</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">This is what the language Forth does.</p></div></div>


</div>
</div></div>
</body>
</html>
